<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">

<head>
    <meta charset="utf-8">
    <!-- Twitter Bootstrap viewport setting -->
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://cdn.f5.com/favicon.ico" rel="icon" />
    <link href="./assets/css/bootstrap.min.css" rel="stylesheet" />
    <link href="./assets/css/f5.css" rel="stylesheet" />
</head>
<body>
<div class="main active" id="content">

    <link href="./assets/css/bootstrap.min.css" rel="stylesheet"></link>
<link href="./assets/css/f5.css" rel="stylesheet"></link>

<h1 id="f5-container-based-solutions-to-provision-big-ips">F5 Container Based Solutions to Provision BIG-IPs</h1>
<ol>
<li><a href="#what-is-the-api-service-gateway-container-">What is the API Services Gateway Container?</a></li>
<li><a href="#what-is-the-as3-container-">What is the AS3 Container?</a></li>
<li><a href="#why-are-we-releasing-new-apis-and-containers-">Why Are We Releasing New APIs and Containers?</a><ul>
<li><a href="#simplifying-big-ip-orchestration-through-declarative-apis">Simplifying BIG-IP Orchestration Through Declarative APIs</a></li>
<li><a href="#we-started-declaring-with-as3">We Started Declaring with AS3</a></li>
<li><a href="#there-is-still-more-to-declare">There Is Still More to Declare</a></li>
</ul>
</li>
<li><a href="#deep-integration-into-an-orchestration-ecosystem">Deep Integration into an Orchestration Ecosystem</a><ul>
<li><a href="#the-api-service-gateway-manifesto">The API Service Gateway Manifesto</a></li>
</ul>
</li>
<li><a href="#which-option-to-choose-for-a-customer-or-partner">Which Option to Choose for a Customer or Partner</a></li>
</ol>
<h2 id="f5-container-orchestration-exercises">F5 Container Orchestration Exercises</h2>
<ol start="6">
<li><a href="#as3-container-exercises">AS3 Container Exercises</a><ul>
<li><a href="#exercise-1-downloading-and-launching-the-as3-container-with-docker">Exercise #1 - Downloading and Launching the AS3 Container with docker</a></li>
<li><a href="#exercise-2-declaring-big-ip-services-through-the-as3-container">Exercise #2 - Declaring BIG-IP Services through the AS3 Container</a></li>
</ul>
</li>
<li><a href="#f5-api-services-gateway-exercises">F5 API Services Gateway Exercises</a><ul>
<li><a href="#exercise-3-downloading-and-launching-the-api-services-gateway-with-docker">Exercise #3 - Downloading and Launching the API Services Gateway with docker</a></li>
<li><a href="#exercise-4-creating-a-trust-between-the-api-service-gateway-and-remote-big-ips">Exercise #4 - Creating a Trust Between the API Service Gateway and Remote BIG-IPs</a></li>
<li><a href="#exercise-5-installing-the-trustedproxy-icontrol-lx-extension-on-the-api-services-gateway">Exercise #5 - Installing TrustedProxy iControl LX Extension on the API Services Gateway</a></li>
<li><a href="#exercise-6-issuing-icontrol-rest-requests-through-the-trustedproxy-icontrol-lx-extension">Exercise #6 - Issuing iControl REST Requests Through the TrustedProxy iControl LX Extension</a></li>
<li><a href="#exercise-7-removing-a-trust-between-the-api-services-gateway-and-a-remote-big-ip">Exercise #7 - Removing a Trust Between the API Service Gateway and a Remote BIG-IP</a></li>
<li><a href="#exercise-8-designing-a-trusteddevices-icontrol-lx-extension-from-json-schema">Exercise #8 - Designing a TrustedDevices iControl LX Extension from JSON Schema</a></li>
<li><a href="#exercise-9-using-the-trustedproxy-icontrol-lx-extension-as-a-token-service">Exercise #9 - Using the TrustedProxy iControl LX Extension As A Token Service</a></li>
<li><a href="#exercise-10-trustedextensions-icontrol-lx-extension-on-the-api-services-gateway">Exercise #10 - TrustedExtensions iControl LX Extension on the API Services Gateway</a></li>
</ul>
</li>
</ol>
<h2 id="integration-exercises">Integration Exercises</h2>
<ol start="8">
<li><a href="#demonstration-integration-exercises">Demonstration Integration Exercises</a><ul>
<li><a href="#exercise-11-launching-the-micro-services-deployment-with-docker-compose">Exercise #11 - Launching The Micro Services Deployment with docker-compose</a></li>
<li><a href="#exercise-12-making-trusted-icontrol-rest-request-to-remote-big-ips">Exercise #12 - Making Trusted iControl REST Request to Remote BIG-IPs</a></li>
<li><a href="#exercise-13-making-trusted-declarations-without-concern-for-tmos-roles">Exercise #13 - Making Trusted Declarations without Concern for TMOS Roles</a></li>
</ul>
</li>
</ol>
<h2 id="summary">Summary</h2>
<ol start="9">
<li><a href="#the-api-service-gateway-in-next-generation-partner-ecosystems">The API Service Gateway in Next Generation Partner Ecosystems</a></li>
<li><a href="#how-can-i-capitalize-on-our-new-f5-orchestration-containers-">How Can I Capitalize On Our New F5 Orchestration Containers?</a></li>
</ol>
<hr>
<p>F5 now offers two container based solutions to aid in the orchestrated provisioning of BIG-IP services.</p>
<ul>
<li><a href="#what-is-the-api-service-gateway-container-">The API Services Gateway Container</a></li>
<li><a href="#what-is-the-as3-container-">The AS3 Container</a></li>
</ul>
<h2 id="what-is-the-api-service-gateway-container-">What is the API Service Gateway Container?</h2>
<p>The <a href="https://hub.docker.com/r/f5devcentral/f5-api-services-gateway/">API Service Gateway Container</a> is a docker built container which runs both the iControl REST framework (restjavad) and the iControl LX extension framework (restnoded). </p>
<p>The API Services Gateway container allows for the installation and operation of iControl LX extensions outside of a BIG-IP.  This enables opportunities for F5, or our customers and partners who are familiar with the iControl LX extensions framework, to run complex iControl REST orchestration workflows in a container, rather then consuming resources on their BIG-IP&#39;s control planes.</p>
<p>In addition to housing iControl LX extensions, the API Services Gateway can be used to create trusted device groups. These device groups establish a certificate based trust between the container and remote BIG-IP devices. Local iControl LX extensions, running within container, can make signed iControl REST requests to peer BIG-IP device without providing TMOS credentials or establishing separate iControl REST session tokens. </p>
<p>Typically iControl REST requires the establishment of a distinct session token with each device. The acquisition of the token requires knowledge of a TMOS username and password which is valid for the remote BIG-IP device. For iControl REST based orchestration projects this has meant the proliferation of TMOS credentials throughout all services requiring access to the BIG-IPs. Too often, these credentials hold TMOS Administrator privileges because of the nature of the iControl REST requests being made. These same TMOS credentials could be use to access the XUI GUI or SSH terminal sessions. An unintended consequence of orchestration has been the expose of TMOS systems to the risk of <em>&#39;leaked&#39;</em> credentials.</p>
<p>With the API Services Gateway, trusted REST calls are signed by the container and the signature is validated on the remote target BIG-IP. If the signature is issued from a member of our trusted device group, the request is carried out with Administrator role permissions on the remote BIG-IP. This is the same process and security used to synchronize configurations between peer TMOS devices. The API Service Gateway thus permits a division of labor where, once a BIG-IP administration process creates the device trust with BIG-IP credentials, other subsequent processes running within the container can be trusted to make iControl REST requests without being concerned with TMOS credentials. This confines the requirement for TMOS credentials to only the API Service Gateway, and then only for the processes of creating the device trust group.</p>
<p><img src="./assets/images/what_is_the_api_gateway_container.png" alt="What is the API Services Gateway Container"></p>
<p><em>The API Services Gateway container is not a generalized API security proxy.</em> It is simply a way of extending our integration options in a cloud native way.</p>
<p>In fact, utilizing the API Services Gateway container to establish trusts removes the need for F5 security on each iControl REST call to remote BIG-IPs. When the F5 security is removed from individual requests, third party security should be used to enforce proper access controls to provision BIG-IP services. Securing access to API endpoints is a major role which is already provided for in most service ecosystems. The API Services Gateway increases the ease of integration for provisioning F5 services to an ecosystem, but then relies on the ecosystem&#39;s native security to authorize requests made to the gateway container.</p>
<p><strong>Note:</strong> The iControl LX extension framework is purpose built to service the orchestration of iControl REST calls issued to TMOS devices. It is <em>NOT</em> suitable as a generalized middleware framework. The iControl LX extension framework filters inbound requests in ways that make it impossible to implement common middleware schemes; such as the injection of identity tokens or anti-tampering measures. The intention of the iControl LX extension framework is to interact with TMOS devices, not external systems. The API Services Gateway container is intended to be used with other linked containers which facilitate interaction with other external systems as part of a micro-services deployment.</p>
<p>The API Services Gateway container is available with community support. As the intention of the container is to become F5&#39;s component in a ecosystem of deployed services. The supportability of the complete orchestration would naturally be beyond F5&#39;s scope. We only handle our part of the overall orchestration.</p>
<p><img src="./assets/images/our_part_of_the_orchestration.png" alt="Our Part in the Orchestration Ecosystem"></p>
<h2 id="what-is-the-as3-container-">What is the AS3 Container?</h2>
<p>The AS3 Container is an F5 optimized API Service Gateway which has the AS3 iControl LX extension pre-installed.</p>
<p>The AS3 Container does not utilize device group trusts. F5 device level authentication and authorization is still enforced by each remote BIG-IP device. The credentials for remote target AS3 deployments are included in the tenant declarations posted to the AS3 container.</p>
<p>The AS3 container is only intended to support the pre-installed AS3 iControl LX extension. The customer should not expect to extend or alter the AS3 container in any way. You run it and use it.</p>
<p>Because the AS3 container&#39;s functionality stands alone, without any dependencies on the customer&#39;s ecosystem of services, it can be maintained as a fully supported F5 product.</p>
<p><img src="./assets/images/what_is_the_as3_container.png" alt="What is the AS3 Container"></p>
<h2 id="why-are-we-releasing-new-apis-and-containers-">Why Are We Releasing New APIs and Containers?</h2>
<p>For the most part, we have successfully migrated our customers and partners who are interested in orchestration to iControl REST. Why introduce new APIs for BIG-IP?</p>
<h3 id="simplifying-big-ip-orchestration-through-declarative-apis">Simplifying BIG-IP Orchestration Through Declarative APIs</h3>
<p>As BIG-IP administration increasingly becomes the job of automation, rather than human administrator interaction, focusing our efforts on simple declarative API interfaces will help our customers standardize their BIG-IP services, increases the agility of operations, and open the orchestration of the TMOS platform to a much larger ecosystem of external cloud services.</p>
<p>For human administrator&#39;s, F5 has augmented the ease of use of TMOS devices in many ways. The XUI Web Graphical Interface performs complex provisioning workflows in behalf of the administrator. The TMSH CLI client uses smart tab completion to assist the administrator with available options for provisioning tasks.</p>
<p><img src="./assets/images/ease_of_use_for_administrators.png" alt="ease of use measures for TMOS administrators"></p>
<p>The complexities of remote provisioning BIG-IP services through iControl REST APIs has been a major hurdle for our customers in their efforts to automated. In our traditional &#39;programmable&#39; fashion, F5 introduced a scriptable framework allowing BIG-IP experts to take very complex provisioning interactions, or workflows, and expose them to non-F5 expert API tenants in a simplified way. The scripting language chosen was javascript. The scriptable APIs are made available as URL namespace <em>&#39;extensions&#39;</em> to the existing iControl REST URL schemas, which start with <code>/mgmt/</code> on every TMOS device.</p>
<pre><code>/mgmt/{{simplified API namespace}}</code></pre><p>The interaction of the scripted workflows with the existing iControl REST API is handled through a set of javascript objects. These objects were called the <em>iControl LX extension framework</em>. In addition, web based UI extensions were enabled, called iApps  LX, allowing the F5 experts to define custom UI elements which can be accessed as part of the BIG-IP device&#39;s XUI web graphical interface.</p>
<p><a href="https://clouddocs.f5.com/products/iapp/iapp-lx/tmos-14_0/">iControl LX Documentation</a> is part of the clouddocs.f5.com effort.</p>
<p>We will not discuss iApps  LX graphical presentations, only the API extensions made available with iControl LX.</p>
<p>Just because a framework exists, like iControl LX extensions, does not mean that the API endpoints exposed by that framework are easy to use. To that end, F5 began to follow a trend in orchestrated provisioning known as <em>&#39;declarative interfaces&#39;</em>. In general, declarative interfaces no longer require the end user to understand the stages and processes by which a system achieves a deployment, but rather simply defines the end service state of a system. </p>
<p>Here is a an example of a YAML declarative deployment for a containerized proxy using the kubernetes orchestrator.</p>
<pre><code class="language-YAML">apiVersion: apps/v1
kind: Deployment
metadata:
  name: www-deployment
  labels:
    app: www
spec:
  replicas: 3
  selector:
    matchLabels:
      app: www
  template:
    metadata:
      labels:
        app: www
    spec:
      containers:
        - name: nginx
          image: nginx:1.7.9
          ports:
            - containerPort: 80
          volumeMounts:
            - mountPath: &quot;/usr/share/nginx/html&quot;
              name: web-pv-storage
---
apiVersion: v1
kind: Service
metadata:
  name: proxy-svc
spec:
  ports:
  - port: 8080
    targetPort: 80
    protocol: TCP
    name: http
  selector:
    app: www</code></pre>
<p>Notice there is nothing in the YAML declaration which pertains to the steps to take in the proxy&#39;s configuration or entries in configuration files. The point of the declarative interface is to decouple and free the API tenant from any such concerns. This notion of decoupling is known as <em>&#39;separation of concerns&#39;</em> and is a basic concept in cloud ready deployments. In cloud, you decompose your systems into independent service interfaces which are only concerned about their part of the overall solution. As as system decomposes into smaller and smaller chunks of system functionality, these decomposed interfaces are referred to as <em>&#39;micro services&#39;</em>.</p>
<h3 id="we-started-declaring-with-as3">We Started Declaring with AS3</h3>
<p>Application Services 3 Extension (AS3) is the first supported declarative API for BIG-IP. AS3 endeavors to expose many advanced BIG-IP services while still hiding as many of the &#39;BIG-IP concerns&#39; as possible. AS3 is an iControl LX extension which, once installed on a system supporting the iControl LX framework, can be accessed at the iControl REST endpoint:</p>
<pre><code>/mgmt/shared/appsvcs</code></pre><p><a href="https://clouddocs.f5.com/products/extensions/f5-appsvcs-extension/3/">Application Services 3 Extension Documentation</a> is part of the clouddocs.f5.com effort.</p>
<p>The AS3 iControl LX extension endpoint accepts a declaration defined by a standards based <a href="https://json-schema.org">JSON schema</a>. AS3 JSON schema allows for an entire BIG-IP&#39;s data plane services to be deployed through one declaration, in one REST call. The AS3 JSON schema includes the ability to define multiple tenants. We call the divisions tenants, verses the BIG-IP concept of partitions, because the API user should not be concerned that BIG-IP has partitions. In cloud, these divisions are typically defined as tenants, not partitions. In fact, if BIG-IP stopped supporting separations with partitions, the API definition of a tenant could remain unchanged. We are quite careful when we define the schema of our declarative APIs to make sure the concepts can be preserved as we pivot to our next generation of application delivery products.</p>
<p><img src="./assets/images/as3_simplified_user_interaction.png" alt="AS3 simplified API Interaction"></p>
<p>AS3&#39;s is constantly being enhanced to include declaration attributes which enable more BIG-IP services. AS3&#39;s aggressive agile based development cycle allows for the release of new AS3 versions on a much shorter release cycle than a full TMOS release. The development team demonstrates and tests new functionality for AS3 every two weeks.</p>
<h3 id="there-is-still-more-to-declare">There Is Still More to Declare</h3>
<p>Other declarative iControl LX extensions are being developed to simplify additional complex TMOS tasks. As an example, AS3 performs extensive validation before implementing its workflows. There are times where AS3&#39;s design might not lend itself to the frequency of automation requests possible in an given ecosystem. For such situations, other declarative APIs could work with AS3 to allow for rapid interaction with specific BIG-IP service objects.</p>
<p>As another example, AS3 does not handle any system-wide onboarding tasks. Other declarative APIs are being developed to handle those type of orchestration requests.</p>
<p>When complex orchestration tasks can be built into standalone micro services, supported containers, like the AS3 container, can become the release packaging. The AS3 container is an example of a standalone micro service just for AS3. Another example of a proposed standalone micro service we are considering, is a container build which unifies the creation and auto-scaling of TMOS VEs in multiple cloud environments. The intent for all such future standalone container builds is to provide simple <em>&#39;run and then use&#39;</em> orchestrations.</p>
<p>All of our declarative APIs and micro service container builds follow the same aggressive development process. Our aim is to be able to provide the simplicity necessary for F5 services to function well in orchestrated environments at the agile pass of our customer&#39;s cloud native deployments. </p>
<h2 id="deep-integration-into-an-orchestration-ecosystem">Deep Integration into an Orchestration Ecosystem</h2>
<p>When declarative iControl LX services are deployed on existing TMOS platforms, they inherit TMOS&#39; system level services, including network access, authentication services, and defined role based authorization. This works well where existing TMOS configurations for corporate identity, like active directory, and network access systems, like established network firewall policies, are already available. However, TMOS&#39; lack of support for cloud native identity systems, TMOS&#39; notions of roles, and the inflexibility of TMOs&#39; tenancy model make integration in the increasingly opinionated world of cloud orchestration extremely cumbersome.</p>
<p><img src="./assets/images/bigip_no_oauth_support.png" alt="BIG-IP does not support customers identity or roles services"></p>
<p>When TMOS forces the exposure of BIG-IP concepts to cloud service API tenants, we are not properly observing <em>&#39;separation of concerns&#39;</em> for our customers. The cloud won&#39;t change for F5, F5 needs to change for the cloud.</p>
<p>In the past F5 has tried to accommodate specific partner ecosystem deployments, for example Cisco APIC or OpenStack Neutron. We did this by creating dedicated agent processes which work inside of the partner&#39;s controllers to <em>translate</em> requests into the workflows needed to provision BIG-IPs. Partner feature dependencies and multiple version testing have proven extremely fragile and complex to maintain.  Fortunately, the technology world had the same problem we did, that of supporting the life cycle of their software in the diversity of cloud services. A better way to handle software deployments in complex ecosystems based on process virtualization has take over our industry. <em>Containerization</em>!</p>
<p>What can F5 do to enable deep integration now that ubiquitous containerization has become available in our customer&#39;s environments?</p>
<p><em>We create our own containers which hides as many of the complexities of integrating with TMOS platforms as possible. That is the reason for the generalized <a href="https://hub.docker.com/r/f5devcentral/f5-api-services-gateway/">API Service Gateway Container</a>. The API Service Gateway container can be integrated into micro service based controllers in ways that make orchestrated provisioning of TMOS devices appear native to the customer&#39;s services. Because of containerization, we can combine the simplicity of our new iControl LX extension declarative APIs with partner ecosystems services without forcing a costly and fragile deployment of one-off, ecosystem specific F5 agents.</em> </p>
<h3 id="the-api-service-gateway-manifesto">The API Service Gateway Manifesto</h3>
<h4 id="our-customers-should-be-able-to-utilize-the-advanced-services-we-offer-with-big-ip-without-being-concerned-about-the-tmos-system-complexities-we-use-to-deploy-those-services-"><strong><em>Our customers should be able to utilize the advanced services we offer with BIG-IP without being concerned about the TMOS system complexities we use to deploy those services.</em></strong></h4>
<p>The marriage of housing our declarative iControl LX extensions and the ability to establish trusted communications with remote BIG-IPs make the API Services Gateway the basis for building F5&#39;s components within an ecosystem&#39;s orchestrated deployment of containers. </p>
<p><strong>Note:</strong> The API Services Gateway is never intended to be the workflow engine at the heart of a deep ecosystem integration. The F5 frameworks it contains are simply not flexible enough to support that functionality. It is intended to remove <em>&#39;TMOS concerns&#39;</em> from the other elements in a deep ecosystem integration project. Interactions with other services in an ecosystems should be handled by other containerized elements which isolate the concerns of those services. In micro-services, cloud ready, fashion, each element plays their role and only their role.</p>
<h2 id="which-option-to-choose-for-a-customer-or-partner">Which Option to Choose for a Customer or Partner</h2>
<h4 id="f5-big-iq-is-the-out-of-the-box-solution-for-big-ip-management-">F5 BIG-IQ is the <em>out of the box</em> solution for BIG-IP management.</h4>
<ul>
<li><p><em>If a customer wants a graphical user interface to manage BIG-IP devices, BIG-IQ provides that interface.</em></p>
</li>
<li><p><em>If a customer wants the ease of use declarative APIs for BIG-IP services available on an F5 managed platform, BIG-IQ 6.1 adds AS3 API endpoints for BIG-IQ managed devices. BIG-IQ will deploy AS3 on remote BIG-IPs and will apply analytics to AS3 declared services.</em></p>
</li>
</ul>
<h4 id="if-your-customer-or-partner-is-looking-for-a-simplified-way-to-fully-control-the-provisioning-of-big-ips-as-part-of-their-own-orchestrated-services-we-now-offer-container-based-solutions-">If your customer or partner is looking for a simplified way to fully control the provisioning of BIG-IPs as part of their own orchestrated services, we now offer container based solutions.</h4>
<ul>
<li><p><em>If a customer wants a standalone way to provision BIG-IP services through a declarative API, the AS3 container performs that function.</em></p>
</li>
<li><p><em>If a customer or partner needs deep integration of BIG-IPs services into an ecosystem of cloud services, the API Service Gateway provides the basis for F5&#39;s components of such a solution.</em></p>
</li>
</ul>
<h3 id="summary-of-solutions">Summary of Solutions</h3>
<table>
<thead>
<tr>
<th align="left">F5 Solution</th>
<th align="left">Support Model</th>
<th align="left">Usage</th>
</tr>
</thead>
<tbody><tr>
<td align="left">F5 BIG-IQ</td>
<td align="left">Full</td>
<td align="left">Full Device Management with a Graphical Environment</td>
</tr>
<tr>
<td align="left">F5 BIG-IQ with AS3</td>
<td align="left">Full</td>
<td align="left">Full Device Management with the Ease of Use Declarative API</td>
</tr>
<tr>
<td align="left">F5 AS3 Container</td>
<td align="left">Full</td>
<td align="left">Ease of Use Declarative API as a Stand Alone Micro Service</td>
</tr>
<tr>
<td align="left">F5 API Services Gateway &nbsp; &nbsp;</td>
<td align="left">Community</td>
<td align="left">F5&#39;s Components of an Integration into an Cloud Services Ecosystem</td>
</tr>
</tbody></table>
<hr>
<h1 id="f5-container-orchestration-exercises">F5 Container Orchestration Exercises</h1>
<hr>
<h2 id="as3-container-exercises">AS3 Container Exercises</h2>
<p>We will deploy the AS3 Container and then declare a BIG-IP device configuration.</p>
<p>In these exercises you will need:</p>
<ul>
<li>A target BIG-IP system whose management address is reachable from the container</li>
<li>Administrative role credentials to the BIG-IP</li>
<li>A running instance of the F5 Container Demonstration Virtual Device</li>
</ul>
<p><img src="./assets/images/f5_container_demonstration_virtual_device_and_bigip_ve.png" alt="Launch Virtual Machines for Exercises"></p>
<hr>
<h3 id="exercise-1-downloading-and-launching-the-as3-container-with-docker">Exercise #1 - Downloading and Launching the AS3 Container with <code>docker</code></h3>
<div class='webcontent'>

<p>Fill in the form below to create your cut-n-paste examples for these exercises.</p>
<hr>
<table>
<thead>
<tr>
<th align="left">Attribute</th>
<th align="left">Explanation</th>
<th align="left">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">deviceIP</td>
<td align="left">The F5 Container Demonstration Virtual Device IP Address</td>
<td align="left">10.1.1.8</td>
</tr>
<tr>
<td align="left">targetHost</td>
<td align="left">The iControl REST remote BIG-IP host, reachable from the container</td>
<td align="left">10.1.1.7</td>
</tr>
<tr>
<td align="left">targetPort</td>
<td align="left">The iControl REST remote BIG-IP port, reachable from the container</td>
<td align="left">443</td>
</tr>
<tr>
<td align="left">targetUsername</td>
<td align="left">The iControl REST username on the remote BIG-IP</td>
<td align="left">admin</td>
</tr>
<tr>
<td align="left">targetPassphrase</td>
<td align="left">The iControl REST password on the remote BIG-IP</td>
<td align="left">admin</td>
</tr>
</tbody></table>
<hr>
<script>
function buildAS3Exercises()
{

    var deviceIp = document.getElementById('as3-container-container-demonstration-virtual-device-ip').value;
    var targetHost = document.getElementById('as3-container-exercises-targetHost').value;
    var targetPort = document.getElementById('as3-container-exercises-targetPort').value;
    var targetUsername = document.getElementById('as3-container-exercises-targetUsername').value;
    var targetPassphrase = document.getElementById('as3-container-exercises-targetPassphrase').value;

    var ssh_login = ``;

    var as3_version_command = `curl -k -s https://localhost:8443/mgmt/shared/appsvcs/info|json_pp
`;

    var as3_version_command_output = `
{
   "schemaMinimum" : "3.0.0",
   "release" : "3",
   "version" : "3.5.0",
   "schemaCurrent" : "3.5.0"
}
`

    var as3_retrieve_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/appsvcs/declare -d '{
    "class": "AS3",
    "action": "retrieve",
    "targetHost": "` + targetHost + `",
    "targetPort": ` + targetPort + `,
    "targetUsername": "` + targetUsername + `",
    "targetPassphrase": "` + targetPassphrase + `"
}'
`;

    var as3_retrieve_command_output = `ubuntu@ip-10-1-1-8:~$ <b>curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/appsvcs/declare -d '{
    "class": "AS3",
    "action": "retrieve",
    "targetHost": "` + targetHost + `",
    "targetPort": ` + targetPort + `,
    "targetUsername": "` + targetUsername + `",
    "targetPassphrase": "` + targetPassphrase + `"
}'

ubuntu@ip-10-1-1-8:~$ <-- Notice no response output!

`;
    var as3_retrieve_command_output_post_to_remote_bigip = `ubuntu@ip-10-1-1-8:~$ curl -u '`+targetUsername+`:`+targetPassphrase+`' -k -s -H 'Content-Type: application/json' -X POST https://` + targetHost + `:` + targetPort + `/mgmt/shared/appsvcs/declare -d '{
>     "class": "AS3",
>     "action": "retrieve"
> }'|json_pp

{
    "statusCode": 404,
    "message": "declaration 0 not found",
    "code": 404
}
`;

    var as3_retrieve_command_output_get_to_remote_bigip = `ubuntu@ip-10-1-1-8:~$ curl -u '`+targetUsername+`:`+targetPassphrase+`' -k -s -H 'Content-Type: application/json' https://` + targetHost + `:` + targetPort + `/mgmt/shared/appsvcs/declare|json_pp

{
    "statusCode": 404,
    "message": "declaration 0 not found",
    "code": 404
}
`;


    var as3_declare_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/appsvcs/declare -d '{
    "class": "AS3",
    "action": "deploy",
    "targetHost": "` + targetHost + `",
    "targetPort": ` + targetPort + `,
    "targetUsername": "` + targetUsername + `",
    "targetPassphrase": "` + targetPassphrase + `",
    "declaration": {
        "class": "ADC",
        "schemaVersion": "3.0.0",
        "id": "container",
        "label": "Sample 1 in a container",
        "remark": "Simple HTTP application with RR pool",
        "Sample_container": {
            "class": "Tenant",
            "A1": {
                "class": "Application",
                "template": "http",
                "serviceMain": {
                "class": "Service_HTTP",
                "virtualAddresses": [
                    "10.0.1.10"
                ],
                "pool": "web_pool"
                },
                "web_pool": {
                "class": "Pool",
                    "monitors": [
                        "http"
                    ],
                "members": [{
                    "servicePort": 80,
                    "serverAddresses": [
                        "192.0.1.10",
                        "192.0.1.11"
                    ]
                }]
                }
            }
        }
    }
}'|json_pp
`;

    var as3_remove_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/appsvcs/declare -d '{
    "class": "AS3",
    "action": "remove",
    "targetHost": "` + targetHost + `",
    "targetPort": ` + targetPort + `,
    "targetUsername": "` + targetUsername + `",
    "targetPassphrase": "` + targetPassphrase + `"
}'|json_pp
`;

    var command_header = `<h4>cut-n-paste command:</h4><code>
    <div style='white-space: pre; font-weight: bold; display: block; border: 1px solid #ccc; border-radius: 0; margin: 0 0 11px; padding: 10.5px;background-color: #f5f5f5;'>`;
    var command_footer = `</div></code>`;
    var sample_header = `<pre>`;
    var sample_footer = `</pre>`;

    // document.getElementById('as3-ssh-login').innerHTML = command_header + ssh_login + command_footer;
    document.getElementById('get-as3-version').innerHTML = command_header + as3_version_command + command_footer;
    document.getElementById('get-as3-version-output').innerHTML = sample_header + as3_version_command_output + sample_footer;
    document.getElementById('get-as3-existing-declaration-command').innerHTML = command_header + as3_retrieve_command + command_footer;
    document.getElementById('get-as3-existing-declaration-command-output').innerHTML = sample_header +as3_retrieve_command_output + sample_footer;
    document.getElementById('as3-declare-example').innerHTML = command_header + as3_declare_command + command_footer;
    document.getElementById('as3-remove-example').innerHTML = command_header + as3_remove_command + command_footer;

}
</script>

<form id='as3-container-exercises-variables'>
<table>
<tr><th>deviceIP: </th><td><input id='as3-container-container-demonstration-virtual-device-ip' placeholder='Device IP' value='10.1.1.8'></td></tr>
<tr><th>targetHost: </th><td><input id='as3-container-exercises-targetHost' placeholder='BIG-IP IP Address' value='10.1.1.7'></td></tr>
<tr><th>targetPort: </th><td><input id='as3-container-exercises-targetPort' placeholder='BIG-IP IP Port' value='443'></td></tr>
<tr><th>targetUsername: </th><td><input id='as3-container-exercises-targetUsername' placeholder='BIG-IP Username' value='admin'></td></tr>
<tr><th>targetPassphrase: </th><td><input id='as3-container-exercises-targetPassphrase' placeholder='BIG-IP Password' value='admin'></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td colspan='2'><input type='button' onclick='buildAS3Exercises()' value=' Generate Exercises Cut-n-Paste Commands '></td></tr>
</table>
</form>

</div>


<p>Step 1. Create a SSH connection to the F5 Container Demonstration Virtual Device</p>
<p>Create a SSH connection to the component called F5 AS3 Container Demonstration in your UDF Blueprint </p>
<p><img src="./assets/images/udf-access-ssh-as3-container.png" alt="F5 Container Demonstration Virtual Device Console"></p>
<div id='as3-ssh-login'>


</div>

<pre><code>Last login: Sun Nov 11 16:04:46 2018 from 10.1.1.254
ubuntu@ip-10-1-1-8:~$
</code></pre><p>Step 2. Pull the AS3 Container from Dockerhub</p>
<p><strong><code>docker pull f5devcentral/f5-as3-container</code></strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ docker pull f5devcentral/f5-as3-container
Using default tag: latest
latest: Pulling from f5devcentral/f5-as3-container
911c6d0c7995: Pulling fs layer
....
....
6ce7b086198f: Pull complete 
Digest: sha256:9ccf5a8e18699742440ea50b9023a9728987d04da4710869e8964d36bcf1d552
Status: Downloaded newer image for f5devcentral/f5-as3-container:latest
</code></pre><p>Step 3. Create a running instance of the AS3 Container</p>
<p><strong><code>docker run --name as3_container --rm -d -p 8443:443 -p 8080:80 f5devcentral/f5-as3-container:latest</code></strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ docker run --name as3_container --rm -d -p 8443:443 -p 8080:80 f5devcentral/f5-as3-container:latest
478d06836ee38fdd48f89e267d7b91c9d3bfb9538c0602e3fdb444062e2f3e54</code></pre><p>List the running containers.</p>
<p><strong><code>docker ps</code></strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ docker ps
CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS                                         NAMES
abeefbf9bbd8        f5devcentral/f5-as3-container:latest   &quot;/etc/runit/boot&quot;        2 minutes ago       Up 2 minutes        0.0.0.0:8080-&gt;80/tcp, 0.0.0.0:8443-&gt;443/tcp   as3_container
f6f0b0dc99a2        jgruber/f5-appsvcs-demo-web:udf        &quot;nginx -g &#39;daemon of…&quot;   4 minutes ago       Up 4 minutes        0.0.0.0:80-&gt;80/tcp                            f5-appsvcs-demo-web
0526bcfb67bb        v2tec/watchtower                       &quot;/watchtower&quot;            About an hour ago   Up About an hour                                                  watchtower
0304edda0fc7        jgruber/as3validatortool               &quot;/bin/sh -c &#39;serve b…&quot;   About an hour ago   Up About an hour    0.0.0.0:5000-&gt;3000/tcp                        as3validator
</code></pre><h3 id="exercise-2-declaring-big-ip-services-through-the-as3-container">Exercise #2 - Declaring BIG-IP Services through the AS3 Container</h3>
<p><strong>Step 1. Validate the version of the AS3 iControl Extension in the AS3 Container</strong></p>
<p>Issue an iControl REST GET request to the AS3 Container with URL ```/mgmt/shared/appsvcs/info``</p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='get-as3-version'>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s  https://localhost:8443/mgmt/shared/appsvcs/info|json_pp
{
   &quot;schemaMinimum&quot; : &quot;3.0.0&quot;,
   &quot;release&quot; : &quot;3&quot;,
   &quot;version&quot; : &quot;3.5.0&quot;,
   &quot;schemaCurrent&quot; : &quot;3.5.0&quot;
}</code></pre></div>

<div id='get-as3-version-output'>

</div>

<p>You should see a returned JSON object which shows the version of the AS3 iControl LX Extension which was pre-installed in the AS3 Container. </p>
<p><strong>Note:</strong> While the iControl REST endpoint is on the AS3 Container, our desire is to make AS3 declarations against remote BIG-IP hosts. Creating a remote configuration for an AS3 declaration is done by including 3 additional attributes. The presence of the <code>targetHost</code>, <code>targetPort</code>, <code>targetUsername</code>, <code>targetPassphrase</code> attributes in the declaration inform the AS3 iControl LX extension that is should not issue iControl REST requests to the local device, but should authenticate against and issue iControl REST requests to the <code>targetHost</code>:<code>targetPort</code> device. We will be including these attributes in all our requests to the AS3 Container endpoint. </p>
<p><strong>Note:</strong> Since declaration attributes are required to target remote BIG-IPs, we won&#39;t be able to make remote declarations with HTTP GET or DELETE requests, which by RFC can not contain a request body. You can query the version from the iControl LX extension with a GET request, but any requests to manage a declaration on a remote BIG-IP must use HTTP POST or PATCH methods.</p>
<p><strong>Step 2. Get any existing AS3 declaration on a remote BIG-IP</strong></p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='get-as3-existing-declaration-command'>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/appsvcs/declare -d &#39;{
    &quot;class&quot;: &quot;AS3&quot;,
    &quot;action&quot;: &quot;retrieve&quot;,
    &quot;targetHost&quot;: &quot;[Your targetHost]&quot;,
    &quot;targetPort&quot;: [Your targetPort],
    &quot;targetUsername&quot;: &quot;[Your targetUsername]&quot;,
    &quot;targetPassphrase&quot;: &quot;[Your targetPassphrase]&quot;
}&#39;</code></pre></div>

<p>If you receive no response output like this:</p>
<div id='get-as3-existing-declaration-command-output'>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/appsvcs/declare -d &#39;{
    &quot;class&quot;: &quot;AS3&quot;,
    &quot;action&quot;: &quot;retrieve&quot;,
    &quot;targetHost&quot;: &quot;[Your targetHost]&quot;,
    &quot;targetUsername&quot;: &quot;[Your targetUsername]&quot;,
    &quot;targetPassphrase&quot;: &quot;[Your targetPassphrase]&quot;
}&#39;

ubuntu@ip-10-1-1-8:~$ &lt;-- Notice no response output!</code></pre></div>

<p>you likely don&#39;t have a previously deployed AS3 declaration. In fact if you add the <code>--version</code> flag to your <code>curl</code> command, you will see you got a <code>204</code> status code in your response.</p>
<p><strong>NOTE:</strong> AS3 Container <code>POST</code> requests with defined <code>targetHost</code>:<code>targetPort</code> and <code>actions</code> attributes <em>do not</em> always mirror the responses of an AS3 iControl LX extension installed on a BIG-IP. This is important to note when testing your orchestrations. You will want to validate your requests against the AS3 container, not just AS3 iControl LX extensions installed locally on BIG-IPs.</p>
<p><strong>Step 3. Issue an AS3 declaration to the a remote BIG-IP</strong></p>
<p>Issue the sample declaration from the AS3 clouddocs documentation to the AS3 Container endpoint. We will add the <code>targetHost</code>, <code>targetPort</code>, <code>targetUsername</code>, and <code>targetPassphrase</code> attributes in the declaration, thus deploying the declaration to your remote BIG-IP.</p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='as3-declare-example'>

</div>

<p>iControl LX extension resources are created within the AS3 Container and then a series of iControl REST requests are issued to the target host BIG-IP to provision the services declared. </p>
<p>Here is what the result should look like. </p>
<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/appsvcs/declare -d &#39;{
    &quot;class&quot;: &quot;AS3&quot;,
    &quot;action&quot;: &quot;deploy&quot;,
    &quot;targetHost&quot;: &quot;[Your targetHost]&quot;,
    &quot;targetPort&quot;: [Your targetPort],
    &quot;targetUsername&quot;: &quot;[Your targetUsername]&quot;,
    &quot;targetPassphrase&quot;: &quot;[Your targetPassphrase]&quot;
    &quot;declaration&quot;: {
        &quot;class&quot;: &quot;ADC&quot;,
        &quot;schemaVersion&quot;: &quot;3.0.0&quot;,
        &quot;id&quot;: &quot;container&quot;,
        &quot;label&quot;: &quot;Sample 1 in a container&quot;,
        &quot;remark&quot;: &quot;Simple HTTP application with RR pool&quot;,
        &quot;Sample_container&quot;: {
            &quot;class&quot;: &quot;Tenant&quot;,
            &quot;A1&quot;: {
                &quot;class&quot;: &quot;Application&quot;,
                &quot;template&quot;: &quot;http&quot;,
                &quot;serviceMain&quot;: {
                &quot;class&quot;: &quot;Service_HTTP&quot;,
                &quot;virtualAddresses&quot;: [
                    &quot;10.0.1.10&quot;
                ],
                &quot;pool&quot;: &quot;web_pool&quot;
                },
                &quot;web_pool&quot;: {
                &quot;class&quot;: &quot;Pool&quot;,
                    &quot;monitors&quot;: [
                        &quot;http&quot;
                    ],
                &quot;members&quot;: [{
                    &quot;servicePort&quot;: 80,
                    &quot;serverAddresses&quot;: [
                        &quot;192.0.1.10&quot;,
                        &quot;192.0.1.11&quot;
                    ]
                }]
                }
            }
        }
    }
}&#39;|json_pp
{
    &quot;results&quot;: [{
        &quot;message&quot;: &quot;success&quot;,
        &quot;lineCount&quot;: 24,
        &quot;code&quot;: 200,
        &quot;host&quot;: &quot;[Your targetHost]&quot;,
        &quot;port&quot;: [Your targetPort],
        &quot;tenant&quot;: &quot;Sample_container&quot;,
        &quot;runTime&quot;: 1077
    }],
    &quot;declaration&quot;: {
        &quot;class&quot;: &quot;ADC&quot;,
        &quot;schemaVersion&quot;: &quot;3.0.0&quot;,
        &quot;id&quot;: &quot;container&quot;,
        &quot;label&quot;: &quot;Sample 1 in a container&quot;,
        &quot;remark&quot;: &quot;Simple HTTP application with RR pool&quot;,
        &quot;Sample_container&quot;: {
            &quot;class&quot;: &quot;Tenant&quot;,
            &quot;A1&quot;: {
                &quot;class&quot;: &quot;Application&quot;,
                &quot;template&quot;: &quot;http&quot;,
                &quot;serviceMain&quot;: {
                    &quot;class&quot;: &quot;Service_HTTP&quot;,
                    &quot;virtualAddresses&quot;: [&quot;10.0.1.10&quot;],
                    &quot;pool&quot;: &quot;web_pool&quot;
                },
                &quot;web_pool&quot;: {
                    &quot;class&quot;: &quot;Pool&quot;,
                    &quot;monitors&quot;: [&quot;http&quot;],
                    &quot;members&quot;: [{
                        &quot;servicePort&quot;: 80,
                        &quot;serverAddresses&quot;: [&quot;192.0.1.10&quot;, &quot;192.0.1.11&quot;]
                    }]
                }
            }
        },
        &quot;controls&quot;: {
            &quot;archiveTimestamp&quot;: &quot;2018-10-06T20:12:08.104Z&quot;
        }
    }
}

ubuntu@ip-10-1-1-8:~$</code></pre><p>The same declaration can be issued to multiple remote BIG-IP hosts by changing the <code>targetHost</code>, <code>targetPort</code>, <code>targetUsername</code>, and <code>targetPassphrase</code> attributes.</p>
<p><strong>Note:</strong> <em>The declaration is maintained in the AS3 Container, however the declared state is implemented on the remote BIG-IP.</em> When our customers use the AS3 container, they can get the advantages of the simplified declarative AS3 API without the need to deploy the AS3 iControl LX extension on fleets of BIG-IPs.</p>
<p><strong>Step 4. Remove an AS3 declaration from a remote BIG-IP</strong></p>
<p>To remove our deployed declaration from our remote BIG-IP, issue a <code>POST</code> request with the <code>remove</code> action to the AS3 Container. We will include our <code>targetHost</code>, <code>targetPort</code>, <code>targetUsername</code>, and <code>targetPassphrase</code> attributes to remove the declaration from the correct remote BIG-IP. </p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='as3-remove-example'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/appsvcs/declare -d &#39;{
    &quot;class&quot;: &quot;AS3&quot;,
    &quot;action&quot;: &quot;remove&quot;,
    &quot;targetHost&quot;: &quot;[Your targetHost]&quot;,
    &quot;targetPort&quot;: [Your targetPort],
    &quot;targetUsername&quot;: &quot;[Your targetUsername]&quot;,
    &quot;targetPassphrase&quot;: &quot;[Your targetPassphrase]&quot;
}&#39;|json_pp
{
    &quot;results&quot;: [
        {
            &quot;message&quot;: &quot;success&quot;,
            &quot;lineCount&quot;: 22,
            &quot;code&quot;: 200,
            &quot;host&quot;: &quot;[Your targetHost]&quot;,
            &quot;port&quot;: [Your targetPort],
            &quot;tenant&quot;: &quot;Sample_container&quot;,
            &quot;runTime&quot;: 21546
        }
    ],
    &quot;declaration&quot;: {
        &quot;class&quot;: &quot;ADC&quot;,
        &quot;schemaVersion&quot;: &quot;3.0.0&quot;,
        &quot;id&quot;: &quot;1538861091968&quot;,
        &quot;updateMode&quot;: &quot;complete&quot;,
        &quot;controls&quot;: {
            &quot;archiveTimestamp&quot;: &quot;2018-10-06T21:25:14.496Z&quot;
        }
    }
}</code></pre><p><strong>Note:</strong> When the API Services Gateway looses connection to the remote BIG-IP while AS3 is validating the configuration, the API Services Gateway will issue an HTTP <code>422 (Unprocessable Entity)</code> error. By itself, AS3 does not retry the declaration request when receiving a 422 error. AS3 was initially designed to declare a configuration to a local BIG-IP, where requests are handled without network latency or connection failures. We are still working through some issues running AS3 remotely. If you received a 422 error when removing the declaration, please retry your removal request until it returns properly.</p>
<p><strong>Step 5. Stop the AS3 Container</strong></p>
<p>To stop the AS3 Container on our F5 Container Demonstration Virtual Device issue the following <code>docker</code> command.</p>
<p><strong><code>docker stop as3_container</code></strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ docker stop as3_container </code></pre><hr>
<h2 id="f5-api-services-gateway-exercises">F5 API Services Gateway Exercises</h2>
<p>We will go through a series of exercises which illustrate the uses of the <a href="https://hub.docker.com/r/f5devcentral/f5-api-services-gateway/">API Service Gateway Container</a> as a place to install and use iControl LX extensions. We will highlight the API Services Gateway acting as trusted gateway to remove BIG-IP concerns from a complex ecosystem integration.</p>
<p>In these exercises you will need:</p>
<ul>
<li>A target BIG-IP system whose management address is reachable from the container</li>
<li>Administrative role credentials to the BIG-IP</li>
<li>A running instance of the F5 Container Demonstration Virtual Device</li>
</ul>
<p><img src="./assets/images/f5_container_demonstration_virtual_device_and_bigip_ve.png" alt="Launch Virtual Machines for Exercises"></p>
<hr>
<h3 id="exercise-3-downloading-and-launching-the-api-services-gateway-with-docker">Exercise #3 - Downloading and Launching the API Services Gateway with <code>docker</code></h3>
<p><strong>Step 1. Create a SSH connection to the F5 Container Demonstration Virtual Device</strong></p>
<div class='webcontent'>

<p>Fill in the form below to create your cut-n-paste examples for these exercises.</p>
<hr>
<table>
<thead>
<tr>
<th align="left">Attribute</th>
<th align="left">Explanation</th>
<th align="left">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">deviceIP</td>
<td align="left">The F5 Container Demonstration Virtual Device IP Address</td>
<td align="left">10.1.1.8</td>
</tr>
<tr>
<td align="left">targetHost</td>
<td align="left">The iControl REST remote BIG-IP host, reachable from the container</td>
<td align="left">10.1.1.7</td>
</tr>
<tr>
<td align="left">targetPort</td>
<td align="left">The iControl REST remote BIG-IP port, reachable from the container</td>
<td align="left">443</td>
</tr>
<tr>
<td align="left">targetUsername</td>
<td align="left">The iControl REST username on the remote BIG-IP</td>
<td align="left">admin</td>
</tr>
<tr>
<td align="left">targetPassphrase</td>
<td align="left">The iControl REST password on the remote BIG-IP</td>
<td align="left">admin</td>
</tr>
</tbody></table>
<hr>
<script>
function buildASGExercises()
{

    var deviceIp = document.getElementById('asg-container-container-demonstration-virtual-device-ip').value;
    var targetHost = document.getElementById('asg-container-exercises-targetHost').value;
    var targetPort = document.getElementById('asg-container-exercises-targetPort').value;
    var targetUsername = document.getElementById('asg-container-exercises-targetUsername').value;
    var targetPassphrase = document.getElementById('asg-container-exercises-targetPassphrase').value;

    var ssh_login = ``;

    var asg_list_device_group_command = `curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/resolver/device-groups|json_pp`;

    var asg_add_device_group_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/resolver/device-groups -d '{
    "groupName": "app1",
    "display": "API Gateway Trust Group",
    "description": "API Gateway Trust Group"
}'|json_pp`;

    var asg_add_device_to_group_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/resolver/device-groups/app1/devices -d '{
    "userName": "` + targetUsername + `",
    "password": "` + targetPassphrase + `",
    "address": "` + targetHost + `",
    "httpsPort": ` + targetPort + `
}'|json_pp`;

    var asg_add_device_to_group_response = `
ubuntu@ip-10-1-1-8:~$ curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/resolver/device-groups/app1/devices -d '
{
    "userName": "` + targetUsername + `",
    "password": "` + targetPassphrase + `",
    "address": "` + targetHost + `",
    "httpsPort": ` + targetPort + `
}'|json_pp

{
    "uuid": "c61e1394-250c-451d-a1c2-fc0f7d1fa99a",
    "deviceUri": "https://10.1.1.7:443",
    "machineId": "c61e1394-250c-451d-a1c2-fc0f7d1fa99a",
    "state": "PENDING",
    "address": "` + targetHost + `",
    "httpsPort": ` + targetPort + `,
    "groupName": "app1",
    "generation": 1,
    "lastUpdateMicros": 1539013176263467,
    "kind": "shared:resolver:device-groups:restdeviceresolverdevicestate",
    "selfLink": "https://localhost/mgmt/shared/resolver/device-groups/app1/devices/c61e1394-250c-451d-a1c2-fc0f7d1fa99a"
}`;

    var asg_query_devices_in_group_command = `curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/resolver/device-groups/app1/devices|json_pp`;

    var asg_download_trust_proxy_command = `curl http://localhost/icontrollx/TrustedProxy/build/RPMS/noarch/TrustedProxy-1.0.0-0001.noarch.rpm -O`;

    var asg_upload_trust_proxy_command = `filepath='/home/ubuntu/TrustedProxy-1.0.0-0001.noarch.rpm'
filename=$(basename $filepath)
rangeheader="Content-Range:0-"$(expr $(stat -c '%s' $filename) - 1)"/"$(stat -c '%s' $filename)
curl -k --header "Content-Type:application/octet-stream" --header $rangeheader -v --data-binary @\${filepath} https://localhost:8443/mgmt/shared/file-transfer/uploads/\${filename}
`;

    var asg_install_trust_proxy_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d '
{ 
    "operation":"INSTALL",
    "packageFilePath": "/var/config/rest/downloads/TrustedProxy-1.0.0-0001.noarch.rpm"
}'|json_pp`;

    var asg_install_trust_proxy_response = `ubuntu@ip-10-1-1-8:~$ curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d '
{ 
    "operation":"INSTALL",
    "packageFilePath": "/var/config/rest/downloads/TrustedProxy-1.0.0-0001.noarch.rpm"
}'|json_pp

{
   "lastUpdateMicros" : 1539100701682596,
   "generation" : 1,
   "ownerMachineId" : "d4b0973a-dea3-4eb9-a281-f6378ed5cfc8",
   "packageFilePath" : "/var/config/rest/downloads/TrustedProxy-1.0.0-0001.noarch.rpm",
   "status" : "CREATED",
   "kind" : "shared:iapp:package-management-tasks:iapppackagemanagementtaskstate",
   "selfLink" : "https://localhost/mgmt/shared/iapp/package-management-tasks/<b>9a559504-f1a2-4dca-a8d6-32ce48f2f896</b>",
   "id" : "<b>9a559504-f1a2-4dca-a8d6-32ce48f2f896</b>",
   "operation" : "INSTALL"
}`;

    var asg_install_query_trust_proxy_command = `curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/iapp/package-management-tasks/[replace with your task id]`;

    var asg_install_query_trust_proxy_response = `ubuntu@ip-10-1-1-8:~$ curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/iapp/package-management-tasks/9a559504-f1a2-4dca-a8d6-32ce48f2f896

{
   "ownerMachineId" : "d4b0973a-dea3-4eb9-a281-f6378ed5cfc8",
   "endTime" : "2018-10-09T15:58:22.207+0000",
   "generation" : 3,
   "selfLink" : "https://localhost/mgmt/shared/iapp/package-management-tasks/9a559504-f1a2-4dca-a8d6-32ce48f2f896",
   "packageName" : "TrustedProxy-1.0.0-0001.noarch",
   "id" : "9a559504-f1a2-4dca-a8d6-32ce48f2f896",
   "status" : "FINISHED",
   "packageManifest" : {
      "tags" : [
         "PLUGIN"
      ]
   },
   "startTime" : "2018-10-09T15:58:21.687+0000",
   "packageFilePath" : "/var/config/rest/downloads/TrustedProxy-1.0.0-0001.noarch.rpm",
   "kind" : "shared:iapp:package-management-tasks:iapppackagemanagementtaskstate",
   "lastUpdateMicros" : 1539100702207190,
   "operation" : "INSTALL"
}`;

    var asg_query_installed_task_extensions_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d '{ "operation":"QUERY"}'|json_pp`;

    var asg_query_installed_task_extensions_response = `ubuntu@ip-10-1-1-8:~$ curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d '{ "operation":"QUERY"}'|json_pp

{
   "generation" : 1,
   "kind" : "shared:iapp:package-management-tasks:iapppackagemanagementtaskstate",
   "ownerMachineId" : "d4b0973a-dea3-4eb9-a281-f6378ed5cfc8",
   "selfLink" : "https://localhost/mgmt/shared/iapp/package-management-tasks/<b>d4bcd95e-1625-49af-ab25-1acfb91f0cb8</b>",
   "id" : "<b>d4bcd95e-1625-49af-ab25-1acfb91f0cb8</b>",
   "status" : "<b>CREATED</b>",
   "lastUpdateMicros" : 1539102136659189,
   "operation" : "QUERY"
}`;

    var asg_query_installed_task_extensions_id_command = `curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/iapp/package-management-tasks/[replace with your task id]|json_pp`;

    var asg_query_installed_task_extensions_id_response = `ubuntu@ip-10-1-1-8:~$curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/iapp/package-management-tasks/d4bcd95e-1625-49af-ab25-1acfb91f0cb8|json_pp
{
   "kind" : "shared:iapp:package-management-tasks:iapppackagemanagementtaskstate",
   "ownerMachineId" : "d4b0973a-dea3-4eb9-a281-f6378ed5cfc8",
   "id" : "d4bcd95e-1625-49af-ab25-1acfb91f0cb8",
   "endTime" : "2018-10-09T16:22:16.672+0000",
   "startTime" : "2018-10-09T16:22:16.661+0000",
   "queryResponse" : [
      {
         "version" : "1.0.0",
         "name" : "TrustedProxy",
         "arch" : "noarch",
         "release" : "0001",
         "tags" : [
            "PLUGIN"
         ],
         "packageName" : "TrustedProxy-1.0.0-0001.noarch"
      }
   ],
   "selfLink" : "https://localhost/mgmt/shared/iapp/package-management-tasks/d4bcd95e-1625-49af-ab25-1acfb91f0cb8",
   "status" : "<b>FINISHED</b>",
   "lastUpdateMicros" : 1539102136672609,
   "operation" : "QUERY",
   "generation" : 3
}`;

    var asg_trusted_proxy_icontrol_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/TrustedProxy -d '{
    "method": "Get",
    "uri": "https://` + targetHost + `:` + targetPort + `/mgmt/shared/identified-devices/config/device-info"
}'|json_pp

`;

    var asg_trusted_proxy_icontrol_response = `ubuntu@ip-10-1-1-8:~$ curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/TrustedProxy -d '{
    "method": "Get",
    "uri": "https://` + targetHost + `:` + targetPort + `/mgmt/shared/identified-devices/config/device-info"
}'|json_pp

{
    "baseMac": "FA:16:3E:E2:38:1C",
    "hostMac": "FA:16:3E:E2:38:1C",
    "time": 1539106693600,
    "halUuid": "ec16fd8e-de21-0c48-91c8-b832af021c9b",
    "physicalMemory": 1984,
    "platform": "Z100",
    "chassisSerialNumber": "ec16fd8e-de21-0c48-b832af021c9b",
    "cpu": "Intel Core Processor (Skylake, IBRS)",
    "slots": [
        {
            "volume": "HD1.1",
            "product": "BIG-IP",
            "version": "13.1.1",
            "build": "0.0.4",
            "isActive": true
        }
    ],
    "license": {
        "licenseEndDateTime": "2018-10-22T00:00:00-07:00",
        "registrationKey": "YDGRF-RBYOD-VTICF-RWPLS-NVMQREY",
        "activeModules": [
            "APM, Base, VE GBB (500 CCU, 2500 Access Sessions)|UBJASLC-ILKNYTP|Anti-Virus Checks|Base Endpoint Security Checks|Firewall Checks|Network Access|Secure Virtual Keyboard|APM, Web Application|Machine Certificate Checks|Protected Workspace|Remote Desktop|App Tunnel",
            "Best Bundle, VE-10G|OYYCOER-KNUABXV|SSL, Forward Proxy, VE|BIG-IP VE, Multicast Routing|DNS and GTM (250 QPS), VE|DataSafe, VE-10G|Advanced Protocols, VE|Rate Shaping|DNSSEC|GTM Licensed Objects, Unlimited|DNS Licensed Objects, Unlimited|DNS Rate Fallback, 250K|GTM Rate Fallback, 250K|GTM Rate, 250K|DNS Rate Limit, 250K QPS|ASM, VE|DNS-GTM, Base, 10Gbps|SSL, VE|Max Compression, VE|AFM, VE|VE, Carrier Grade NAT (AFM ONLY)|Routing Bundle, VE|PSM, VE",
            "PEM, ADD-VE, 5G|AMYJFJF-MBSAFPC"
        ],
        "generation": 0,
        "lastUpdateMicros": 1537969975812010
    },
    "interfaces": [
        "mgmt",
        "1.2",
        "1.1"
    ],
    "isIControlRestSupported": true,
    "icrdPort": 8100,
    "machineId": "c61e1394-250c-451d-a1c2-fc0f7d1fa99a",
    "address": "1.1.1.104",
    "hostname": "test-bigip1.sample.openstack.f5se.com",
    "version": "13.1.1",
    "product": "BIG-IP",
    "platformMarketingName": "BIG-IP Virtual Edition",
    "edition": "Final",
    "build": "0.0.4",
    "restFrameworkVersion": "13.1.1-0.0.4",
    "managementAddress": "192.168.245.105",
    "mcpDeviceName": "/Common/test-bigip1.novalocal",
    "trustDomainGuid": "f419bf5b-d194-4c68-96c0fa163ee2381c",
    "isClustered": false,
    "isVirtual": true,
    "generation": 0,
    "lastUpdateMicros": 0,
    "kind": "shared:resolver:device-groups:deviceinfostate",
    "selfLink": "https://localhost/mgmt/shared/identified-devices/config/device-info"
}`

    var asg_download_trust_device_command = 'curl -O http://localhost/icontrollx/TrustedDevices/build/RPMS/noarch/TrustedDevices-1.0.0-0001.noarch.rpm';

    var asg_upload_trust_device_command = `filepath='/home/ubuntu/TrustedDevices-1.0.0-0001.noarch.rpm'
filename=$(basename $filepath)
rangeheader="Content-Range:0-"$(expr $(stat -c '%s' $filename) - 1)"/"$(stat -c '%s' $filename)
curl -k --header "Content-Type:application/octet-stream" --header $rangeheader -v --data-binary @\${filepath} https://localhost:8443/mgmt/shared/file-transfer/uploads/\${filename}
`;

    var asg_install_trust_device_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d '
{ 
    "operation":"INSTALL",
    "packageFilePath": "/var/config/rest/downloads/TrustedDevices-1.0.0-0001.noarch.rpm"
}'|json_pp`;

    var asg_get_trust_device_command = `curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/TrustedDevices|json_pp`;

    var asg_remove_trust_device_command = `curl -k -s -H 'Content-Type: application/json' -X POST -d '{"devices": []}' https://localhost:8443/mgmt/shared/TrustedDevices|json_pp`;

    var asg_add_trust_device_command = `curl -k -s -H 'Content-Type: application/json' -X POST -d '{"devices": [{"targetHost":"${targetHost}", "targetPort":${targetPort}, "targetUsername":"${targetUsername}", "targetPassphrase":"${targetPassphrase}"}]}' https://localhost:8443/mgmt/shared/TrustedDevices|json_pp`;

    var asg_get_tokens = `curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/TrustedProxy|json_pp`;

    var asg_use_token = `token="[Your Token Here]"
curl -k -s -H 'Content-Type: application/json' https://${targetHost}:${targetPort}/mgmt/shared/identified-devices/config/device-info?$token|json_pp`;

    var asg_download_trust_extension_command = `curl -O http://localhost/icontrollx/TrustedExtensions/build/RPMS/noarch/TrustedExtensions-1.0.0-0001.noarch.rpm`;

    var asg_upload_trust_extension_command = `filepath='/home/ubuntu/TrustedExtensions-1.0.0-0001.noarch.rpm'
filename=$(basename $filepath)
rangeheader="Content-Range:0-"$(expr $(stat -c '%s' $filename) - 1)"/"$(stat -c '%s' $filename)
curl -k --header "Content-Type:application/octet-stream" --header $rangeheader -v --data-binary @\${filepath} https://localhost:8443/mgmt/shared/file-transfer/uploads/\${filename}`;

    var asg_install_trust_extension_command = `curl -k -s -H 'Content-Type: application/json' -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d '{ 
    "operation":"INSTALL",
    "packageFilePath": "/var/config/rest/downloads/TrustedExtensions-1.0.0-0001.noarch.rpm"
}'|json_pp`;

    var asg_get_trust_extension_command = `curl -k -s -H 'Content-Type: application/json' https://localhost:8443/mgmt/shared/TrustedExtensions?targetHost=localhost|json_pp`;

    var app_docker_compose_up = `docker-compose up`;
    var app_docker_compose_down = `docker-compose down`;
    var app_openapi_url = `<a href='http://${deviceIp}:3000/api-docs' target='_blank'>http://${deviceIp}:3000/api-docs</a>`;

    var command_header = `<h4>cut-n-pase command:</h4><code>
    <div style='white-space: pre-wrap; word-wrap: break-word; font-weight: bold; display: block; border: 1px solid #ccc; border-radius: 0; margin: 0 0 11px; padding: 10.5px;background-color: #f5f5f5;'>`;
    var command_footer = `</div></code>`;
    var sample_header = `<pre>`;
    var sample_footer = `</pre>`;

    // document.getElementById('asg-ssh-login').innerHTML = command_header + ssh_login + command_footer;
    document.getElementById('asg-list-device-group-command').innerHTML = command_header + asg_list_device_group_command + command_footer;
    document.getElementById('asg-add-device-group-command').innerHTML = command_header + asg_add_device_group_command + command_footer;
    document.getElementById('asg-add-device-to-group-command').innerHTML = command_header + asg_add_device_to_group_command + command_footer;
    document.getElementById('asg-add-device-to-group-response').innerHTML = sample_header + asg_add_device_to_group_response + sample_footer;
    document.getElementById('asg-query-devices-in-group-command').innerHTML = command_header + asg_query_devices_in_group_command + command_footer;
    document.getElementById('asg-download-trust-proxy-command').innerHTML = command_header + asg_download_trust_proxy_command + command_footer;
    document.getElementById('asg-upload-trust-proxy-command').innerHTML = command_header + asg_upload_trust_proxy_command + command_footer;
    document.getElementById('asg-install-trust-proxy-command').innerHTML = command_header + asg_install_trust_proxy_command + command_footer;
    document.getElementById('asg-install-trust-proxy-response').innerHTML = sample_header + asg_install_trust_proxy_response + sample_footer;
    document.getElementById('asg-install-query-trust-proxy-command').innerHTML = command_header + asg_install_query_trust_proxy_command + command_footer;
    document.getElementById('asg-install-query-trust-proxy-response').innerHTML = sample_header + asg_install_query_trust_proxy_response + sample_footer;
    document.getElementById('asg-query-installed-task-extensions-command').innerHTML = command_header + asg_query_installed_task_extensions_command + command_footer;
    document.getElementById('asg-query-installed-task-extensions-response').innerHTML = sample_header + asg_query_installed_task_extensions_response + sample_footer;
    document.getElementById('asg-query-installed-task-extensions-id-command').innerHTML = command_header + asg_query_installed_task_extensions_id_command + command_footer;
    document.getElementById('asg-download-trust-device-command').innerHTML = command_header + asg_download_trust_device_command + command_footer;
    document.getElementById('asg-upload-trust-device-command').innerHTML = command_header + asg_upload_trust_device_command + command_footer;
    document.getElementById('asg-install-trust-device-command').innerHTML = command_header + asg_install_trust_device_command + command_footer;
    document.getElementById('asg-trusted-proxy-icontrol-command').innerHTML = command_header + asg_trusted_proxy_icontrol_command + command_footer;
    document.getElementById('asg-trusted-proxy-icontrol-response').innerHTML = sample_header + asg_trusted_proxy_icontrol_response + sample_footer;
    document.getElementById('asg-get-trust-device-command').innerHTML = command_header + asg_get_trust_device_command + command_footer;
    document.getElementById('asg-remove-trust-device-command').innerHTML = command_header + asg_remove_trust_device_command + command_footer;
    document.getElementById('asg-add-trust-device-command').innerHTML = command_header + asg_add_trust_device_command + command_footer;
    document.getElementById('asg-get-tokens').innerHTML = command_header + asg_get_tokens + command_footer;
    document.getElementById('asg-use-token').innerHTML = command_header + asg_use_token + command_footer;
    document.getElementById('asg-download-trust-extension-command').innerHTML = command_header + asg_download_trust_extension_command + command_footer;
    document.getElementById('asg-upload-trust-extension-command').innerHTML = command_header + asg_upload_trust_extension_command + command_footer;
    document.getElementById('asg-install-trust-extension-command').innerHTML = command_header + asg_install_trust_extension_command + command_footer;
    document.getElementById('asg-get-trust-extension-command').innerHTML = command_header + asg_get_trust_extension_command + command_footer;
    document.getElementById('app-docker-compose-up').innerHTML = command_header + app_docker_compose_up + command_footer;
    document.getElementById('app-docker-compose-down').innerHTML = command_header + app_docker_compose_down + command_footer;
    document.getElementById('app-openapi-url').innerHTML = command_header + app_openapi_url + command_footer;
}
</script>

<form id='asg-container-exercises-variables'>
<table>
<tr><th>deviceIP: </th><td><input id='asg-container-container-demonstration-virtual-device-ip' placeholder='Device IP' value='10.1.1.8'></td></tr>
<tr><th>targetHost: </th><td><input id='asg-container-exercises-targetHost' placeholder='BIG-IP IP Address' value='10.1.1.7'></td></tr>
<tr><th>targetPort: </th><td><input id='asg-container-exercises-targetPort' placeholder='BIG-IP IP Port' value='443'></td></tr>
<tr><th>targetUsername: </th><td><input id='asg-container-exercises-targetUsername' placeholder='BIG-IP Username' value='admin'></td></tr>
<tr><th>targetPassphrase: </th><td><input id='asg-container-exercises-targetPassphrase' placeholder='BIG-IP Password' value='admin'></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td colspan='2'><input type='button' onclick='buildASGExercises()' value=' Generate Exercises Cut-n-Paste Commands '></td></tr>
</table>
</form>

</div>

<p>Create a SSH connection to the component called F5 AS3 Container Demonstration in your UDF Blueprint </p>
<p><img src="./assets/images/udf-access-ssh-as3-container.png" alt="F5 Container Demonstration Virtual Device Console"></p>
<div id='asg-ssh-login'>

</div>

<pre><code>Last login: Sun Nov 11 16:04:46 2018 from 10.1.1.254
ubuntu@ip-10-1-1-8:~$
</code></pre><p><strong>Step 2. Pull the API Services Gateway Container from Dockerhub</strong></p>
<p><strong><code>docker pull f5devcentral/f5-api-services-gateway</code></strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ docker pull f5devcentral/f5-api-services-gateway
Using default tag: latest
latest: Pulling from f5devcentral/f5-api-services-gateway
911c6d0c7995: Already exists 
9a55ca73fa67: Pulling fs layer 
....
....
8ad0544354f6: Pull complete 
Digest: sha256:6d425a974564940fb7a86bfd899d17999260cf16f839f9ab451b99ef38c68b7e
Status: Downloaded newer image for f5devcentral/f5-api-services-gateway:latest</code></pre><p><strong>Step 3. Create a running instance of the API Services Gateway</strong></p>
<p><strong><code>docker run --name asg_container --rm -d -p 8443:443 -p 8080:80 f5devcentral/f5-api-services-gateway:latest</code></strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ docker run --name asg_container --rm -d -p 8443:443 -p 8080:80 f5devcentral/f5-api-services-gateway:latest
1c93dd6fa06e7f63df22953d0a0facb20635d7db74ca9a322f798fe3ff582119</code></pre><h3 id="exercise-4-creating-a-trust-between-the-api-service-gateway-and-remote-big-ips">Exercise #4 - Creating a Trust Between the API Service Gateway and Remote BIG-IPs</h3>
<p>The main use case for the API Services Gateway is to add an container based service which decouples all the TMOS concerns from the rest of the orchestration services. One of the major concerns imposed by TMOS is its authentication and roles based authorizations. To remove those concerns we are going to create a device trust between the API Services Gateway and a remote BIG-IP.</p>
<p>In TMOS, the ability to issue trusted requests is contingent on a remote device being registered in a device group. We will start by </p>
<ol>
<li>Querying for device groups present in the API Services Gateway</li>
<li>Creating a device group on the API Services Gateway</li>
<li>Populating our newly created device group with a trusted remote BIG-IP</li>
</ol>
<p><strong>Step 1. Query for existing device group trusts</strong></p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='asg-list-device-group-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/resolver/device-groups|json_pp
{
    &quot;items&quot;: [
        {
            &quot;groupName&quot;: &quot;dockerContainers&quot;,
            &quot;devicesReference&quot;: {
                &quot;link&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/dockerContainers/devices&quot;
            },
            &quot;description&quot;: &quot;Docker Containers Group&quot;,
            &quot;displayName&quot;: &quot;Docker Containers Group&quot;,
            &quot;isViewGroup&quot;: false,
            &quot;infrastructure&quot;: false,
            &quot;generation&quot;: 1,
            &quot;lastUpdateMicros&quot;: 1539009502371689,
            &quot;kind&quot;: &quot;shared:resolver:device-groups:devicegroupstate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/dockerContainers&quot;
        },
        {
            &quot;groupName&quot;: &quot;dockerContainersLegacyXXX&quot;,
            &quot;devicesReference&quot;: {
                &quot;link&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/dockerContainersLegacyXXX/devices&quot;
            },
            &quot;description&quot;: &quot;Docker Containers Group for legacy BIG-IP devices&quot;,
            &quot;displayName&quot;: &quot;Docker Containers Group for legacy BIG-IP devices&quot;,
            &quot;isViewGroup&quot;: false,
            &quot;infrastructure&quot;: false,
            &quot;generation&quot;: 1,
            &quot;lastUpdateMicros&quot;: 1539009502371285,
            &quot;kind&quot;: &quot;shared:resolver:device-groups:devicegroupstate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/dockerContainersLegacyXXX&quot;
        }
    ],
    &quot;generation&quot;: 2,
    &quot;kind&quot;: &quot;shared:resolver:device-groups:devicegroupcollectionstate&quot;,
    &quot;lastUpdateMicros&quot;: 1539009502372133,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups&quot;
}</code></pre><p><strong>Note:</strong> The API Services Gateway automatically creates two device groups <code>dockerContainers</code> and <code>dockerCOntainersLegacyXXX</code>. In the API Services Gateway documentation is states that trusted devices can be added by populating the ENV (environment variable for <code>docker</code>) <code>BIGIP_LIST</code>. There is an iControl LX extension pre-installed on the API Services Gateway which will attempt to query the <code>BIGIP_LIST</code> ENV variable and then populate these pre-installed device groups with specified BIG-IPs. If the queried BIG-IP device is running TMOS v12 or higher, it will create a trust for the device by adding it to the <code>dockerContainers</code> device group. If the BIG-IP device is running TMOS prior to 12.0, it will create a trust for the device by adding it to the <code>dockerContainersLegacyXXX</code> device group. </p>
<p><strong>Note:</strong> <em>It is not recommended that you use the API Services Gateway with TMOS versions less than 13.1.</em></p>
<hr>
<p><strong><em>STOP! - MAKE SURE YOUR TARGET BIG-IPS HAVE A CONFIG SYNC INTERFACE CONFIGURED. EVEN IF IT IS STANDALONE, THE API SERVICES GATEWAY REQUIRES IT TO CREATE A TRUST! READ BELOW</em></strong></p>
<p><img src="./assets/images/f5-apps-tmos-xui-config-sync.png" alt="Configure TMOS Config Sync"></p>
<p><code>tmsh modify cm device [device_name] configsync-ip [selfipaddress]</code></p>
<p><strong>Note:</strong> <em>Becuase trusted device requests use the same mechanisms as TMOS configuration synchronization, there is a limitation in TMOS which requires our remote BIG-IP devices to have their <code>configsync-ip</code> interface populated with a non-floating SelfIP.</em></p>
<p><em>While the trusted queries can be issued to your remote BIG-IP&#39;s management IP address, if your remote BIG-IP does not have its <code>configsync-ip</code> populated, it will not be able to discover its own device certificate, which is used to sign responses to your queries. This design limitation is slated to be removed in a future release of TMOS.</em></p>
<p><em>If your remote BIG-IP does not have a <code>configsync-ip</code> set, please configure this before you continue.</em></p>
<hr>
<p>To illustrate every step needed to create device trusts, we will ignore the <code>BIGIP_LIST</code> ENV variable and the pre-installed <code>dockerContainers</code> and <code>dockerContainersLegacyXXX</code> device groups which the API Services Gateway team added to ease this concern.  We will create a new device group and establish trust step by step. We do this so you can learn not only how it works, but understand how to troubleshoot any problems you experence. </p>
<p>Later we will create an iControl LX extension to allow the addition of trusted devices dynamically through a declarative interface!</p>
<p><strong>Step 2. Make a iControl REST POST request to add a tusted remote BIG-IP</strong></p>
<p>You can name your device group any valid TMOS name. We will add a device group named <code>app1</code>.</p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='asg-add-device-group-command'>

</div>

<div id='asg-add-device-group-response'>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/resolver/device-groups -d &#39;{
    &quot;groupName&quot;: &quot;app1&quot;,
    &quot;display&quot;: &quot;API Gateway Trust Group&quot;,
    &quot;description&quot;: &quot;API Gateway Trust Group&quot;
}&#39;|json_pp

{
    &quot;groupName&quot;: &quot;app1&quot;,
    &quot;devicesReference&quot;: {
        &quot;link&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices&quot;
    },
    &quot;description&quot;: &quot;API Gateway Trust Group&quot;,
    &quot;isViewGroup&quot;: false,
    &quot;infrastructure&quot;: false,
    &quot;generation&quot;: 1,
    &quot;lastUpdateMicros&quot;: 1539011370204203,
    &quot;kind&quot;: &quot;shared:resolver:device-groups:devicegroupstate&quot;,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1&quot;
}</code></pre></div>

<p><strong>Note:</strong> <em>The request to create the device group required no authentication or authorization.</em> The API Services Gateway does not, by default, enforce any authentication model. This relieves us from that concern. In fact, we exposed both <code>80</code> and <code>443</code> TCP port from the container. We could issue all these requests without encryption too.  We will later mitigate these concerns by limiting network access to the API Service Gateway to only trusted containers on a private network. The idea of restricting access to services as a means to relieve concerns is a basic concept for container orchestrations. It is important to realize that removing concerns, even security concerns, is a goal at this phase of our development process.</p>
<p><strong>Note:</strong> If your customer would like to add the concern of <em>minimal security</em> to the API Services Gateway, they can enable the requirement for HTTP BASIC authentication for all requests. 
The API Services Gateway includes an Apache web server, like TMOS does, which can implement the HTTP BASIC authentication scheme. You can config Apache to require <code>htpasswd</code> files (basic passwords) or to use LDAP queries to authenticate requests.</p>
<p>The Apache configuration directives can be enabled by attaching <code>docker</code> volumes, which mount a directory containing your configuration files, or by building your own container based on the API Services Gateway. When building a container, the authentication configuration files are copied into the container&#39;s file system using the Dockerfile <code>COPY</code> directive.</p>
<p><a href="https://github.com/jgruber/f5-asg-builder">For a hint how to do this check this link out</a></p>
<p>We felt the need to burden the container with Apache because our customers might desire to run the API Service Gateway as a standalone API endpoint instead of its intended placement in a micro services orchestration. We understand sometimes you just want a fast way to get something done.</p>
<p><strong>Step 3. Add our remote BIG-IP to our device group.</strong></p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='asg-add-device-to-group-command'>

</div>

<div id='asg-add-device-to-group-response'>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/resolver/device-groups/app1/devices -d &#39;{
    &quot;userName&quot;: &quot;[Your Remote BIG-IP Username]&quot;,
    &quot;password&quot;: &quot;[Your Remote BIG-IP Password]&quot;,
    &quot;address&quot;: &quot;[Your Remote BIG-IP]&quot;,
    &quot;httpsPort&quot;: &quot;443&quot;
}&#39;|json_pp

{
    &quot;uuid&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
    &quot;deviceUri&quot;: &quot;https://10.1.1.7:443&quot;,
    &quot;machineId&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
    &quot;state&quot;: &quot;PENDING&quot;,
    &quot;address&quot;: &quot;10.1.1.7&quot;,
    &quot;httpsPort&quot;: 443,
    &quot;groupName&quot;: &quot;app1&quot;,
    &quot;generation&quot;: 1,
    &quot;lastUpdateMicros&quot;: 1539013176263467,
    &quot;kind&quot;: &quot;shared:resolver:device-groups:restdeviceresolverdevicestate&quot;,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices/c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;
}</code></pre></div>

<p><strong>Note:</strong> The response shows the state of our device addition as <code>PENDING</code>. At this point, the API Services Gateway is initiating an exchange of device certificates with the remote BIG-IP. <em>Remote BIG-IP credentials are only required to initiate the exchange of certificates required for the trust.</em> Once the devices exchange certificates, and device group membership is established, iControl LX extensions running on the API Services Gateway can issue iControl REST requests to trusted remote BIG-IPs <strong><em>without</em></strong> providing TMOS credentials or establishing an iControl REST session token.</p>
<p><strong>Step 4. Query the status of the device trust to assure it is ACTIVE</strong></p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='asg-query-devices-in-group-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/resolver/device-groups/app1/devices|json_pp

{
    &quot;items&quot;: [
        {
            &quot;uuid&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;,
            &quot;deviceUri&quot;: &quot;https://172.17.0.2:443&quot;,
            &quot;machineId&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;,
            &quot;state&quot;: &quot;ACTIVE&quot;,
            &quot;address&quot;: &quot;172.17.0.2&quot;,
            &quot;httpsPort&quot;: 443,
            &quot;groupName&quot;: &quot;app1&quot;,
            &quot;generation&quot;: 1,
            &quot;lastUpdateMicros&quot;: 1539013176668106,
            &quot;kind&quot;: &quot;shared:resolver:device-groups:restdeviceresolverdevicestate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices/adec4506-656f-4aee-a94a-2414ee63f3ec&quot;
        },
        {
            &quot;uuid&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
            &quot;deviceUri&quot;: &quot;https://10.1.1.7:443&quot;,
            &quot;machineId&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
            &quot;state&quot;: &quot;ACTIVE&quot;,
            &quot;address&quot;: &quot;10.1.1.7&quot;,
            &quot;httpsPort&quot;: 443,
            &quot;hostname&quot;: &quot;test-bigip1.sample.openstack.f5se.com&quot;,
            &quot;version&quot;: &quot;13.1.1&quot;,
            &quot;product&quot;: &quot;BIG-IP&quot;,
            &quot;platformMarketingName&quot;: &quot;BIG-IP Virtual Edition&quot;,
            &quot;edition&quot;: &quot;Final&quot;,
            &quot;build&quot;: &quot;0.0.4&quot;,
            &quot;restFrameworkVersion&quot;: &quot;13.1.1-0.0.4&quot;,
            &quot;managementAddress&quot;: &quot;192.168.245.105&quot;,
            &quot;mcpDeviceName&quot;: &quot;/Common/test-bigip1.novalocal&quot;,
            &quot;trustDomainGuid&quot;: &quot;f419bf5b-d194-4c68-96c0fa163ee2381c&quot;,
            &quot;properties&quot;: {
                &quot;shared:resolver:device-groups:discoverer&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;
            },
            &quot;isClustered&quot;: false,
            &quot;isVirtual&quot;: true,
            &quot;groupName&quot;: &quot;app1&quot;,
            &quot;generation&quot;: 3,
            &quot;lastUpdateMicros&quot;: 1539013178608469,
            &quot;kind&quot;: &quot;shared:resolver:device-groups:restdeviceresolverdevicestate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices/c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;
        }
    ],
    &quot;generation&quot;: 4,
    &quot;kind&quot;: &quot;shared:resolver:device-groups:devicegroupdevicecollectionstate&quot;,
    &quot;lastUpdateMicros&quot;: 1539013178610088,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices&quot;
}</code></pre><p><strong>Note:</strong> The response shows two devices in our device group. One is the API Services Gateway with a state of <code>ACTIVE</code>. The other is our remote BIG-IP, which should also show its state as <code>ACTIVE</code>. You can continue to add remote BIG-IPs to the device group, thus enabling iControl LX extensions installed on the API Service Gateway to have many remote trusted BIG-IPs as request targets.</p>
<p>If your remote BIG-IP does not reach the <code>ACTIVE</code> state, you likely have one of two issues:</p>
<ol>
<li>The API Services Gateway can not reach the address and port issued in the <code>POST</code> request to add the device.</li>
<li>You did not assure your remote BIG-IP device has its <code>configsync-ip</code> set to a non-floating SelfIP. Without this, the remote device can not discover its own certificate to exchange with the API Services Gateway.</li>
</ol>
<p>If your remote BIG-IP did not reach the <code>ACTIVE</code> state, remove the errant device by issue <code>DELETE</code> requests to the device link in the device group, and then re-populate the device entry in the device group by issuing a <code>POST</code> request providing the appropriate request body. </p>
<h3 id="exercise-5-installing-the-trustedproxy-icontrol-lx-extension-on-the-api-services-gateway">Exercise #5 - Installing the TrustedProxy iControl LX Extension on the API Services Gateway</h3>
<p>To utilize our established trust between the API Services Gateway and a remote BIG-IP, we need to issue iControl REST requests <strong><em>from</em></strong> the API Service Gateway. We are going to create a simple iControl LX extension which will proxy requests from external clients to trusted remote BIG-IPs. </p>
<p>Our new proxy iControl LX extension will accept only POST requests. The body of our POST will contain the details of the desired iControl REST requests to perform on our remote BIG-IPs. The iControl LX proxy extension will take our request, <strong>1)</strong> use the iControl LX framework to sign the request with the API Services Gateway device key, <strong>2)</strong> send the signed request to the remote BIG-IP. The remote BIG-IP will <strong>3)</strong> validate the signature using its device group copy of the API Services Gateway certificate, <strong>4)</strong> perform the iControl REST requested actions, <strong>5)</strong> sign the response using its own device key and respond back to the API Service Gateway. The API Services Gateway will <strong>6)</strong> validate the response using its device group copy of the remote BIG-IP certificate, and lastly <strong>7)</strong> proxy the iControl REST response to the remote client.</p>
<p><img src="./assets/images/icontrollx_trusted_proxy_extension.png" alt="Established Trust through iControl LX extensions"></p>
<p>Most of this process is actually done as part of the iControl REST service. This is how our Enterprise Manager, BIG-IQ, and iWorkflow all securely communicated with TMOS since iControl REST was introduced. By adding the iControl REST framework to the API Services Gateway, we gain this secured communication service.</p>
<p>Fortunately, the iControl REST framework has made this whole process very simple to use within iControl LX extensions. The key iControl LX framework component which enables us to issued signed requests for members of our trusted device group is the <code>RestOperation</code> eventChannel object class. There are two methods which enable the use of signed requests.</p>
<hr>
<table>
<thead>
<tr>
<th align="left">RestOperation method</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>setIdentifiedDeviceRequest(boolean)</code></td>
<td align="left">if true, check if the host part of the requested URL matches a trusted device. If it does, create and inject the signed request header. Defaults to false.</td>
</tr>
<tr>
<td align="left"><code>setIdentifiedDeviceGroupName(device_trust_group_name)</code></td>
<td align="left">(optional) Only check the host part of the URL against the named device group. Defaults to <code>null</code> which will check all device groups available on the local device.</td>
</tr>
</tbody></table>
<hr>
<p>Here is the source code for our TrustedProxy iControl LX extension for your investigation.</p>
<p><strong><strong>TrustedProxy iControl LX extension code</strong></strong></p>
<pre><code>&quot;use strict&quot;;

/**
 * Trusted Device Proxy which handles only POST requests
 * @constructor
 */
class TrustedProxyWorker {
    constructor() {
        this.WORKER_URI_PATH = &quot;shared/TrustedProxy&quot;;
        this.isPublic = true;
    }

    /**
     * handle onPost HTTP request - proxy request to trusted device.
     * @param {Object} restOperation
     */
    onPost(restOperation) {
        const body = restOperation.getBody();
        const refThis = this;
        // Create the framework request RestOperation to proxy to a trusted device.
        let identifiedDeviceRequest = this.restOperationFactory.createRestOperationInstance()
            // Tell the ASG to resolve trusted device for this request.
            .setIdentifiedDeviceRequest(true)
            .setIdentifiedDeviceGroupName(body.groupName)
            // Discern the type of request to proxy from the &#39;method&#39; attributes in the request body.
            .setMethod(body.method || &quot;Get&quot;)
            // Discern the URI for the request to proxy from the &#39;uri&#39; attribute in the request body. 
            .setUri(this.url.parse(body.uri))
            // Discern the HTTP headers for the request to proxy from the &#39;headers&#39; attribute in the request body.
            .setHeaders(body.headers || restOperation.getHeaders())
            // Discern the HTTP body for the request to proxy from the &#39;body&#39; attribute in the request body.
            .setBody(body.body)
            // Derive the referer from the parsed URI.
            .setReferer(this.getUri().href);

        this.eventChannel.emit(this.eventChannel.e.sendRestOperation, identifiedDeviceRequest,
            function (resp) {
                // Return the HTTP status code from the proxied response.
                restOperation.statusCode = resp.statusCode;
                // Return the HTTP headers from the proxied response.
                restOperation.headers = resp.headers;
                // Return the body from the proxied response.
                restOperation.body = resp.body;
                // emmit event to complete this response through the REST framework.
                refThis.completeRestOperation(restOperation);
            },
            function (err) {
                // The proxied response was an error. Forward the error through the REST framework.
                refThis.logger.severe(&quot;Request to %s failed: \n%s&quot;, body.uri, err ? err.message : &quot;&quot;);
                restOperation.fail(err);
            }
        );
    }
}

module.exports = TrustedProxyWorker;</code></pre><p>The TrustedProxy iControl LX extension handles only POST requests. The necessary details for the type of iControl REST request to make to a trusted BIG-IP are included in the POST body.</p>
<hr>
<table>
<thead>
<tr>
<th align="left">TrustedProxy POST body attributes</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">method</td>
<td align="left">Must be &#39;Get&#39;,&#39;Post&#39;,&#39;Put&#39;,&#39;Patch&#39;, or &#39;Delete&#39;. The iControl LX method format to proxy to the trusted BIG-IP.</td>
</tr>
<tr>
<td align="left">uri</td>
<td align="left">The iControl REST uri. The host portion will be used to determine the trusted BIG-IP from the device group.</td>
</tr>
<tr>
<td align="left">headers</td>
<td align="left">(optional) The HTTP headers to pass to the trusted BIG-IP.</td>
</tr>
<tr>
<td align="left">contentType</td>
<td align="left">(optional) The HTTP Content-Type to pass to the trusted BIG-IP.</td>
</tr>
<tr>
<td align="left">body</td>
<td align="left">(optional) The HTTP request body to pass to the trusted BIG-IP.</td>
</tr>
<tr>
<td align="left">groupName</td>
<td align="left">(optional) Limited the trusted BIG-IP host lookup to the named device group.</td>
</tr>
</tbody></table>
<hr>
<p><strong><em>Helpful links to iControl LX Resources</em></strong></p>
<p>While you don&#39;t need to understand the TrustedProxy iControl LX extension code, if you wanted to, here are links to the documentation which will help.</p>
<p><a href="https://clouddocs.f5.com/products/iapp/iapp-lx/tmos-14_0/">iControl LX clouddocs</a></p>
<p><a href="https://github.com/elv1s/iControlLX-generator">iControl LX Generator</a></p>
<p><a href="https://clouddocs.f5.com/products/iapp/iapp-lx/tmos-14_0/icontrollx_nodejs_sdk_appendix/restoperation.html">iControl LX RestOperation SDK doc</a></p>
<p><a href="https://devcentral.f5.com/wiki/iControlREST.HomePage.ashx">iControl REST doc</a></p>
<p>There are several steps involved in publishing an iControl LX extension via the iControl REST framework. </p>
<p><strong>Note:</strong> Just like it did for device group trust building, the API Services Gateway has an iControl LX extension pre-installed which will look for iControl LX extension source code or RPM files copied into the container&#39;s <code>/root/lx</code> directory. You can use <code>Dockerfile</code> <code>COPY</code> directives to copy your extensions into the base API Services Gateway container. </p>
<p>Because we educating you on how to utilize the API Services Gateway, we will show you the steps involved in publishing iControl LX extensions through iControl REST. It is a valuable thing to learn as this is the same process to follow for iControl LX extensions publishing across all F5 platforms which support iControl LX.</p>
<p><strong>Step 1. Upload the TustedProxy iControl LX extension RPM file to the API Services Gateway Container</strong></p>
<p>iControl REST supports uploading files to remote devices. A detailed discussion can be found here:</p>
<p><a href="https://devcentral.f5.com/articles/demystifying-icontrol-rest-part-5-transferring-files">Demystifying iControl REST Part 5: Transferring Files</a></p>
<p>The TrustedProxy RPM file is available at <a href="/icontrollx/TrustedProxy/build/RPMS/noarch/TrustedProxy-1.0.0-0001.noarch.rpm">/icontrollx/TrustedProxy/build/RPMS/noarch/TrustedProxy-1.0.0-0001.noarch.rpm</a>. We can download it into the <code>ubuntu</code> user&#39;s home directory of the F5 Container Demonstration Virtual Device using curl. </p>
<div id='asg-download-trust-proxy-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl http://localhost/icontrollx/TrustedProxy/build/RPMS/noarch/TrustedProxy-1.0.0-0001.noarch.rpm -O
ubuntu@ip-10-1-1-8:~$ ls -l /home/ubuntu/TrustedProxy-1.0.0-0001.noarch.rpm 
-rw-rw-r-- 1 ubuntu ubuntu 7728 Oct  1 09:56 /home/ubuntu/TrustedProxy-1.0.0-0001.noarch.rpm</code></pre><p>We created the F5 Container Demonstration Virtual Device for your convience. Be aware that the RPM package for our iControl LX extension could be uploaded into the API Services Gateway container from anywhere that has access to the API Services Gateway iControl REST endpoints.</p>
<p><strong>Use bash and curl in the F5 Container Demonstration Device SSH session</strong></p>
<p>Set the following bash variables and run the following <code>curl</code> command to upload the TrsutedProxy iControl LX extension from the F5 Container Demonstration Virtual Device into the API Services Gateway container.</p>
<div id='asg-upload-trust-proxy-command'>

</div>

<div id='asg-upload-trust-proxy-response'>

<pre><code>ubuntu@ip-10-1-1-8:~$ filepath=&#39;/home/ubuntu/TrustedProxy-1.0.0-0001.noarch.rpm&#39;
ubuntu@ip-10-1-1-8:~$ filename=$(basename $filepath)
ubuntu@ip-10-1-1-8:~$ rangeheader=&quot;Content-Range:0-&quot;$(expr $(stat -c &#39;%s&#39; $filename) - 1)&quot;/&quot;$(stat -c &#39;%s&#39; $filename)
ubuntu@ip-10-1-1-8:~$ curl -k --header &quot;Content-Type:application/octet-stream&quot; --header $rangeheader -v --data-binary @${filepath} https://localhost:8443/mgmt/shared/file-transfer/uploads/${filename}

{&quot;remainingByteCount&quot;:0,&quot;usedChunks&quot;:{&quot;0&quot;:7728},&quot;totalByteCount&quot;:7728,&quot;localFilePath&quot;:&quot;/var/config/rest/downloads/TrustedProxy-1.0.0-0001.noarch.rpm&quot;,&quot;temporaryFilePath&quot;:&quot;/var/config/rest/downloads/tmp/TrustedProxy-1.0.0-0001.noarch.rpm&quot;,&quot;generation&quot;:0,&quot;lastUpdateMicros&quot;:1539099747522073}</code></pre></div>

<p>You can examine what the script above is doing. It is uploading our RPM file to an iControl REST endpoint <em>a chunk at a time</em>. The iControl REST FileWorker is taking these chunks and reassembling the final uploaded file. This is an example of <em>file streaming</em> our RPM to the API Services Gateway over HTTP. <em>File streaming</em> is another fundamental way micro services handle file processing. <em>File Streaming</em> allows for the resumption of uploading along chunk boundaries.</p>
<p><strong>Step 2. Make a request to initiate an install task for the TrustedProxy iControl LX Extension in the API Services Gateway Container</strong></p>
<p>iControl LX extension RPMs are not like standard Red Hat RPM files. You can not simply use the <code>rpm</code> utilities and libraries to install iControl LX extensions. The installation of an iControl LX extension requires the iControl REST framework to run an install <em>&#39;task&#39;</em> in your behalf. While this breaks our ability to use standard RPM publishing (RPM repository downloads, cloud-init installation, ansible package modules, etc), it does some very micro service friendly things for us. </p>
<p>The use of iControl REST extension install tasks accomplishes two things. </p>
<p>First, it makes the installation task <em>asynchronous</em>. You initiate the task which then <em>runs in the background</em>. You can query the progress of your install task at any time after initiating the task. Get used to this pattern of behavior. Asynchronous request processing is a major way we increase the efficiency and concurrency of services. </p>
<p>Secondly, using install tasks allows for the decomposition of the installation into <em>stages</em>. Only one of these <em>stages</em> includes using RPMs to copy the files into the right place. Another stage in the install process publishes the extension URL namespace. Without this, you could not access your extension through the iControl REST service listener (you know at <code>/mgmt/[YOUR EXTENSION NAMESPACE HERE]</code>). Internally iConrol REST itself is a collection of workers all accessed through the same service listener (the <code>restjavad</code> process listening on TCP 127.0.0.1:8100 on each host). Our extension code simply becomes a way to publish a new worker to which the iControl REST listener can issue requests.</p>
<p>We can always create <em>wrapper</em> RPM files which turn the install back into a synchronous process, but enable the use of standard RPM tools. Obviously the RPMs would require iControl REST to be running in order to install or uninstall our extensions. We still need the install to handle all phases of the process.</p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<p>Create an install task for your uploaded iControl LX RPM file.</p>
<div id='asg-install-trust-proxy-command'>

</div>


<div id='asg-install-trust-proxy-response'>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d &#39;{ 
    &quot;operation&quot;:&quot;INSTALL&quot;,
    &quot;packageFilePath&quot;: &quot;/var/config/rest/downloads/TrustedProxy-1.0.0-0001.noarch.rpm&quot;
}&#39;|json_pp

{
   &quot;lastUpdateMicros&quot; : 1539100701682596,
   &quot;generation&quot; : 1,
   &quot;ownerMachineId&quot; : &quot;d4b0973a-dea3-4eb9-a281-f6378ed5cfc8&quot;,
   &quot;packageFilePath&quot; : &quot;/var/config/rest/downloads/TrustedProxy-1.0.0-0001.noarch.rpm&quot;,
   &quot;status&quot; : &quot;CREATED&quot;,
   &quot;kind&quot; : &quot;shared:iapp:package-management-tasks:iapppackagemanagementtaskstate&quot;,
   &quot;selfLink&quot; : &quot;https://localhost/mgmt/shared/iapp/package-management-tasks/9a559504-f1a2-4dca-a8d6-32ce48f2f896&quot;,
   &quot;id&quot; : &quot;9a559504-f1a2-4dca-a8d6-32ce48f2f896&quot;,
   &quot;operation&quot; : &quot;INSTALL&quot;
}</code></pre></div>


<p>Upon creation, our new task has a status of <code>CREATED</code>. The API Service Gateway is now trying to install the TrustedProxy iControl LX extension from the uploaded RPM file.</p>
<p>We can query its status by extracting the task <code>id</code> from our creation response, appending the id to the URL, and issuing a <code>GET</code> request.</p>
<div id='asg-install-query-trust-proxy-command'>

</div>

<div id='asg-install-query-trust-proxy-response'>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/iapp/package-management-tasks/[your task id]

{
   &quot;ownerMachineId&quot; : &quot;d4b0973a-dea3-4eb9-a281-f6378ed5cfc8&quot;,
   &quot;endTime&quot; : &quot;2018-10-09T15:58:22.207+0000&quot;,
   &quot;generation&quot; : 3,
   &quot;selfLink&quot; : &quot;https://localhost/mgmt/shared/iapp/package-management-tasks/9a559504-f1a2-4dca-a8d6-32ce48f2f896&quot;,
   &quot;packageName&quot; : &quot;TrustedProxy-1.0.0-0001.noarch&quot;,
   &quot;id&quot; : &quot;9a559504-f1a2-4dca-a8d6-32ce48f2f896&quot;,
   &quot;status&quot; : &quot;FINISHED&quot;,
   &quot;packageManifest&quot; : {
      &quot;tags&quot; : [
         &quot;PLUGIN&quot;
      ]
   },
   &quot;startTime&quot; : &quot;2018-10-09T15:58:21.687+0000&quot;,
   &quot;packageFilePath&quot; : &quot;/var/config/rest/downloads/TrustedProxy-1.0.0-0001.noarch.rpm&quot;,
   &quot;kind&quot; : &quot;shared:iapp:package-management-tasks:iapppackagemanagementtaskstate&quot;,
   &quot;lastUpdateMicros&quot; : 1539100702207190,
   &quot;operation&quot; : &quot;INSTALL&quot;
}
</code></pre></div>

<p>The task should reach a status of <code>FINISHED</code>.</p>
<p><strong>Note:</strong> You should be careful when you decide to install iControl LX extensions. <strong><em>Installing a new extension requires the entire iControl LX framework to be restarted</em></strong>. If you have other running extensions which keep ephemeral data in memory or are currently handling other requests, they will be interrupted. The easiest way to assure this does not happen is to start your API Services Gateway and immediately install all required extensions.</p>
<p>The cloud native way around the framework restart issue would be to decompose such concerns into individual services (containers). You very well could have a separate API Services Gateway for each iControl LX extension. This is currently the case for the AS3 Container. Do you see why we have an AS3 Container now?</p>
<p><strong>Step 3. Make a request to initiate a query task to inventory the iControl LX extensions in the API Services Gateway Container</strong></p>
<p>To see a listing of what iControl LX extensions are installed, you need to create a <em>&#39;task&#39;</em> which will inventory the locally installed extensions and return a report.</p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<p>Create an query task to inventory your locally installed iControl LX extensions.</p>
<div id='asg-query-installed-task-extensions-command'>

</div>

<div id='asg-query-installed-task-extensions-response' >

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d &#39;{ &quot;operation&quot;:&quot;QUERY&quot;}&#39;|json_pp

{
   &quot;generation&quot; : 1,
   &quot;kind&quot; : &quot;shared:iapp:package-management-tasks:iapppackagemanagementtaskstate&quot;,
   &quot;ownerMachineId&quot; : &quot;d4b0973a-dea3-4eb9-a281-f6378ed5cfc8&quot;,
   &quot;selfLink&quot; : &quot;https://localhost/mgmt/shared/iapp/package-management-tasks/d4bcd95e-1625-49af-ab25-1acfb91f0cb8&quot;,
   &quot;id&quot; : &quot;d4bcd95e-1625-49af-ab25-1acfb91f0cb8&quot;,
   &quot;status&quot; : &quot;CREATED&quot;,
   &quot;lastUpdateMicros&quot; : 1539102136659189,
   &quot;operation&quot; : &quot;QUERY&quot;
}</code></pre></div>

<p><strong>Step 4. Make an iControl REST GET request to retrieve the results of your query task</strong></p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<p>Pulling the <code>id</code> attribute from the returned task, append the task id to your URL and issue a <code>GET</code> request to return your inventory report. </p>
<div id='asg-query-installed-task-extensions-id-command' >

</div>

<div id='asg-query-installed-task-extensions-id-response' >

<pre><code>ubuntu@ip-10-1-1-8:~$curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/iapp/package-management-tasks/d4bcd95e-1625-49af-ab25-1acfb91f0cb8|json_pp
{
   &quot;kind&quot; : &quot;shared:iapp:package-management-tasks:iapppackagemanagementtaskstate&quot;,
   &quot;ownerMachineId&quot; : &quot;d4b0973a-dea3-4eb9-a281-f6378ed5cfc8&quot;,
   &quot;id&quot; : &quot;d4bcd95e-1625-49af-ab25-1acfb91f0cb8&quot;,
   &quot;endTime&quot; : &quot;2018-10-09T16:22:16.672+0000&quot;,
   &quot;startTime&quot; : &quot;2018-10-09T16:22:16.661+0000&quot;,
   &quot;queryResponse&quot; : [
      {
         &quot;version&quot; : &quot;1.0.0&quot;,
         &quot;name&quot; : &quot;TrustedProxy&quot;,
         &quot;arch&quot; : &quot;noarch&quot;,
         &quot;release&quot; : &quot;0001&quot;,
         &quot;tags&quot; : [
            &quot;PLUGIN&quot;
         ],
         &quot;packageName&quot; : &quot;TrustedProxy-1.0.0-0001.noarch&quot;
      }
   ],
   &quot;selfLink&quot; : &quot;https://localhost/mgmt/shared/iapp/package-management-tasks/d4bcd95e-1625-49af-ab25-1acfb91f0cb8&quot;,
   &quot;status&quot; : &quot;FINISHED&quot;,
   &quot;lastUpdateMicros&quot; : 1539102136672609,
   &quot;operation&quot; : &quot;QUERY&quot;,
   &quot;generation&quot; : 3
}</code></pre></div>

<p>The extension inventory report should have a record in the <code>queryResponse</code> reply attribute confirming your TrustedProxy iControl LX extension is installed properly.</p>
<h3 id="exercise-6-issuing-icontrol-rest-requests-through-the-trustedproxy-icontrol-lx-extension">Exercise #6 - Issuing iControl REST Requests Through the TrustedProxy iControl LX Extension</h3>
<p><strong><em>What the TrustProxy iControl LX extension is doing for us</em></strong></p>
<p>Recall our endeavor was to remove the TMOS authentication and role authorization concerns from our orchestration services. We required remote TMOS credentials to establish the trusted device group, but once a device has an established trust with our API Services Gateway, we should not need them anymore. The trust relationship however requires us to issue the iControl REST calls from the trusted API Services Gateway. </p>
<p>Our TrustedProxy extension provides the mechanism to issue iControl REST calls from outside the API Service Gateway, but take advantage of the trust relationship it has. This is an example of building infrastructure services with the iControl LX extension framework. It is very powerful. Whenever you have some iControl REST process which is either overly complicated or presents a concern which is only associated with F5, we use iControl LX extensions to handle it.</p>
<p>In this scenario, our ability to take advantage of the work f5 has done to create iControl LX for TMOS has enabled us to remove the need for tenants to have TMOS credentials. We are no longer <em>&#39;leaking&#39;</em> TMOS device credentials to remote users. Seeing that some of our API declarations, like AS3, require TMOS Administrator role, this is an important <em>&#39;separation of concerns&#39;</em> issue for F5 to deal with. We can now free our customers to user their own desired tools to secure access to the API Service Gateway, rather then forcing them to have secured access to all remote BIG-IPs. This is huge for our ability to integrate into ecosystems.</p>
<p><strong>Step 1. Make an iControl REST GET request through the TrustedProxy iControl LX Extension to a remote BIG-IP without credentials.</strong></p>
<p>TrustedProxy iControl LX extension is registered to take <code>POST</code> requests at the iControl REST endpoint <code>/shared/TrustedProxy</code>.</p>
<p>We will use a basic example here, but you can issue any iControl REST request via HTTP POST requests to the TrustedProxy iControl LX extension.</p>
<p>Here is the basic &#39;Get&#39; request example we will use:</p>
<pre><code>POST https://localhost:8443/mgmt/shared/TrustedProxy

{
    &quot;method&quot;: &quot;Get&quot;,
    &quot;uri&quot;: &quot;https://[Your Remote BIG-IP Address]:[Your Remote BIG-IP Port]/mgmt/shared/identified-devices/config/device-info&quot;
}
</code></pre><p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<div id='asg-trusted-proxy-icontrol-command'>

</div>

<div id='asg-trusted-proxy-icontrol-response'>


<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/TrustedProxy -d &#39;{
    &quot;method&quot;: &quot;Get&quot;,
    &quot;uri&quot;: &quot;https://10.1.1.7/mgmt/shared/identified-devices/config/device-info&quot;
}&#39;|json_pp

{
    &quot;baseMac&quot;: &quot;FA:16:3E:E2:38:1C&quot;,
    &quot;hostMac&quot;: &quot;FA:16:3E:E2:38:1C&quot;,
    &quot;time&quot;: 1539106693600,
    &quot;halUuid&quot;: &quot;ec16fd8e-de21-0c48-91c8-b832af021c9b&quot;,
    &quot;physicalMemory&quot;: 1984,
    &quot;platform&quot;: &quot;Z100&quot;,
    &quot;chassisSerialNumber&quot;: &quot;ec16fd8e-de21-0c48-b832af021c9b&quot;,
    &quot;cpu&quot;: &quot;Intel Core Processor (Skylake, IBRS)&quot;,
    &quot;slots&quot;: [
        {
            &quot;volume&quot;: &quot;HD1.1&quot;,
            &quot;product&quot;: &quot;BIG-IP&quot;,
            &quot;version&quot;: &quot;13.1.1&quot;,
            &quot;build&quot;: &quot;0.0.4&quot;,
            &quot;isActive&quot;: true
        }
    ],
    &quot;license&quot;: {
        &quot;licenseEndDateTime&quot;: &quot;2018-10-22T00:00:00-07:00&quot;,
        &quot;registrationKey&quot;: &quot;YDGRF-RBYOD-VTICF-RWPLS-NVMQREY&quot;,
        &quot;activeModules&quot;: [
            &quot;APM, Base, VE GBB (500 CCU, 2500 Access Sessions)|UBJASLC-ILKNYTP|Anti-Virus Checks|Base Endpoint Security Checks|Firewall Checks|Network Access|Secure Virtual Keyboard|APM, Web Application|Machine Certificate Checks|Protected Workspace|Remote Desktop|App Tunnel&quot;,
            &quot;Best Bundle, VE-10G|OYYCOER-KNUABXV|SSL, Forward Proxy, VE|BIG-IP VE, Multicast Routing|DNS and GTM (250 QPS), VE|DataSafe, VE-10G|Advanced Protocols, VE|Rate Shaping|DNSSEC|GTM Licensed Objects, Unlimited|DNS Licensed Objects, Unlimited|DNS Rate Fallback, 250K|GTM Rate Fallback, 250K|GTM Rate, 250K|DNS Rate Limit, 250K QPS|ASM, VE|DNS-GTM, Base, 10Gbps|SSL, VE|Max Compression, VE|AFM, VE|VE, Carrier Grade NAT (AFM ONLY)|Routing Bundle, VE|PSM, VE&quot;,
            &quot;PEM, ADD-VE, 5G|AMYJFJF-MBSAFPC&quot;
        ],
        &quot;generation&quot;: 0,
        &quot;lastUpdateMicros&quot;: 1537969975812010
    },
    &quot;interfaces&quot;: [
        &quot;mgmt&quot;,
        &quot;1.2&quot;,
        &quot;1.1&quot;
    ],
    &quot;isIControlRestSupported&quot;: true,
    &quot;icrdPort&quot;: 8100,
    &quot;machineId&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
    &quot;address&quot;: &quot;1.1.1.104&quot;,
    &quot;hostname&quot;: &quot;test-bigip1.sample.openstack.f5se.com&quot;,
    &quot;version&quot;: &quot;13.1.1&quot;,
    &quot;product&quot;: &quot;BIG-IP&quot;,
    &quot;platformMarketingName&quot;: &quot;BIG-IP Virtual Edition&quot;,
    &quot;edition&quot;: &quot;Final&quot;,
    &quot;build&quot;: &quot;0.0.4&quot;,
    &quot;restFrameworkVersion&quot;: &quot;13.1.1-0.0.4&quot;,
    &quot;managementAddress&quot;: &quot;192.168.245.105&quot;,
    &quot;mcpDeviceName&quot;: &quot;/Common/test-bigip1.novalocal&quot;,
    &quot;trustDomainGuid&quot;: &quot;f419bf5b-d194-4c68-96c0fa163ee2381c&quot;,
    &quot;isClustered&quot;: false,
    &quot;isVirtual&quot;: true,
    &quot;generation&quot;: 0,
    &quot;lastUpdateMicros&quot;: 0,
    &quot;kind&quot;: &quot;shared:resolver:device-groups:deviceinfostate&quot;,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/identified-devices/config/device-info&quot;
}</code></pre></div>

<p>The response is the same as if we had issued a <code>GET</code> request to the remote BIG-IP&#39;s <code>/mgmt/shared/identified-devices/config/device-info</code> iControl REST endpoint, but we are no longer concerned with TMOS credentials or TMOS roles. The request, issued through the trust, runs as an Administrator role on the remote BIG-IP.</p>
<p><strong><em>Look Mom No Leaked Credentials!</em></strong></p>
<p><strong>WE HAVE ESTABLISHED A TRUSTED CONTAINER WITHOUT HAVING TENANTS KNOW TMOS CREDENTIALS</strong></p>
<h3 id="exercise-7-removing-a-trust-between-the-api-services-gateway-and-a-remote-big-ip">Exercise #7 - Removing a Trust Between the API Services Gateway and a Remote BIG-IP</h3>
<p><strong>Note:</strong> This exercise is here for completeness. You should read it, but in Exercise 8 we are going to make this whole process a simple declaration!</p>
<p>While the creation of the trust was an automated process which was initiated by the addition of a BIG-IP to a device group, the removal of trust must be done through multiple requests. </p>
<p>The process to remove the trust has six steps:</p>
<ol>
<li>Query the device group on the API Services Gateway collecting the device <code>machineIds</code> for both the API Services Gateway and the remote BIG-IP which we are removing the trust</li>
<li>Using the TrustedProxy extension, query the <code>certificateId</code> for the API Services Gateway on the remote BIG-IP</li>
<li>Using the TrustedProxy extension, remove the API Services Gateway certificate from your remote BIG-IP</li>
<li>Remove the remote BIG-IP from the API Services Gateway device group</li>
<li>Query the remote BIG-IP <code>certificateId</code> from the API Services Gateway</li>
<li>Remove the remote BIG-IP&#39;s certificate on the API Services Gateway</li>
</ol>
<p><strong>Step 1. Query the device group for device <code>machineIds</code> for both the API Services Gateway and our remote BIG-IP</strong></p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/resolver/device-groups/app1/devices|json_pp

{
    &quot;items&quot;: [
        {
            &quot;uuid&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;,
            &quot;deviceUri&quot;: &quot;https://172.17.0.2:443&quot;,
            &quot;machineId&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;,
            &quot;state&quot;: &quot;ACTIVE&quot;,
            &quot;address&quot;: &quot;172.17.0.2&quot;,
            &quot;httpsPort&quot;: 443,
            &quot;groupName&quot;: &quot;app1&quot;,
            &quot;generation&quot;: 1,
            &quot;lastUpdateMicros&quot;: 1539013176668106,
            &quot;kind&quot;: &quot;shared:resolver:device-groups:restdeviceresolverdevicestate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices/adec4506-656f-4aee-a94a-2414ee63f3ec&quot;
        },
        {
            &quot;uuid&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
            &quot;deviceUri&quot;: &quot;https://10.1.1.7:443&quot;,
            &quot;machineId&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
            &quot;state&quot;: &quot;ACTIVE&quot;,
            &quot;address&quot;: &quot;10.1.1.7&quot;,
            &quot;httpsPort&quot;: 443,
            &quot;hostname&quot;: &quot;test-bigip1.sample.openstack.f5se.com&quot;,
            &quot;version&quot;: &quot;13.1.1&quot;,
            &quot;product&quot;: &quot;BIG-IP&quot;,
            &quot;platformMarketingName&quot;: &quot;BIG-IP Virtual Edition&quot;,
            &quot;edition&quot;: &quot;Final&quot;,
            &quot;build&quot;: &quot;0.0.4&quot;,
            &quot;restFrameworkVersion&quot;: &quot;13.1.1-0.0.4&quot;,
            &quot;managementAddress&quot;: &quot;192.168.245.105&quot;,
            &quot;mcpDeviceName&quot;: &quot;/Common/test-bigip1.novalocal&quot;,
            &quot;trustDomainGuid&quot;: &quot;f419bf5b-d194-4c68-96c0fa163ee2381c&quot;,
            &quot;properties&quot;: {
                &quot;shared:resolver:device-groups:discoverer&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;
            },
            &quot;isClustered&quot;: false,
            &quot;isVirtual&quot;: true,
            &quot;groupName&quot;: &quot;app1&quot;,
            &quot;generation&quot;: 3,
            &quot;lastUpdateMicros&quot;: 1539013178608469,
            &quot;kind&quot;: &quot;shared:resolver:device-groups:restdeviceresolverdevicestate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices/c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;
        }
    ],
    &quot;generation&quot;: 4,
    &quot;kind&quot;: &quot;shared:resolver:device-groups:devicegroupdevicecollectionstate&quot;,
    &quot;lastUpdateMicros&quot;: 1539013178610088,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices&quot;
}
</code></pre><p>Record the <code>machineId</code> for both the Application Services Gateway and your remote BIG-IP. </p>
<p>From our query, here is an example of what to record:</p>
<p>API Services Gateway machineId: adec4506-656f-4aee-a94a-2414ee63f3ec</p>
<p>Remote BIG-IP machineId: c61e1394-250c-451d-a1c2-fc0f7d1fa99a</p>
<p><em>Your <code>machineId</code>s will be different from the example. Don&#39;t cut-n-pas them.</em></p>
<p><strong>Step 2. Using the TrustedProxy extension, query the <code>certificateId</code> for the API Services Gateway on the remote BIG-IP</strong></p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/TrustProxy -d &#39;   
{
   &quot;method&quot;:&quot;Get&quot;,
   &quot;uri&quot;: &quot;https://10.1.1.7:443/mgmt/shared/device-certificates&quot;
}&#39;|json_pp

{
    &quot;items&quot;: [
        {
            &quot;certificateId&quot;: &quot;1.1.1.104&quot;,
            &quot;machineId&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
            &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIC2jCCAcKgAwIBAgIEGFbjgzANBgkqhkiG9w0BAQUFADAvMS0wKwYDVQQDDCRj\nNjFlMTM5NC0yNTBjLTQ1MWQtYTFjMi1mYzBmN2QxZmE5OWEwHhcNMTgwOTA1MTgy\nMzQ0WhcNMjgwOTAzMTgyMzQ0WjAvMS0wKwYDVQQDDCRjNjFlMTM5NC0yNTBjLTQ1\nMWQtYTFjMi1mYzBmN2QxZmE5OWEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\nAoIBAQDruU0PO02LbQKkRVYTz4AIq9t90YlRHKqj3jMWZ4mzbbKH0u0NCv3N5f4w\n4cbAQTp1UAi1wu71H6eLm8AVQw0sgTyhcVbSpSIoN2fD8a1RpbtLNpz7EjohPnMh\nTh0ooBnpwwXz0THs/dx/v1M97Dh8VSE8+q90ibJE4k259111GUyG1ZrlWkqAT1gD\n71zHOOICfcmNpL4eFNI18K3OZAZ7pxroQctRre2d19I6KpqiUwNFrNEQ002mu/WM\nMQrm8PrFvK4c93JZ3wTqcixIl+Xkgf8YHQv/tEqapsndMb+qIgQCRsvX192xQTsm\nnRFuVnihMpmjdC6v5gw8VP0CGK+fAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAG00\n9WWq36mVjNXknzHuoxd/pQOMZX9j3WBonPiTkvD9uXKlEtywEmTzJ+yagqUHBYjT\nQEOrNsc12huI40d5Y7Xr8/NCo6SQxxnyphpbiMI/DGaJLltSoogYRZzfr1Da/7k+\nQ+R9ITWV8aBvnAZ4yokIgkAwvSOILc3mIOy3Zfoja2SFNJPxPIpEAXilC71JrtVW\n+vSc6ezuKAXfzWbh2T3KNfEW9QZ7LDy4Auc4/P+vIVXffApk7ytJriJHXrV24RSq\nfsVP3GF2km0dkNMa5Zw3nq5RNRaosLa2MqMt/3xUfWUb8QSsTCAme0IEvgU0i0yo\nZU6oSQxXONf+2UI/8AI=\n-----END CERTIFICATE-----\n&quot;,
            &quot;lastUpdateMicros&quot;: 1537468411723624,
            &quot;kind&quot;: &quot;shared:device-certificates:devicecertificatestate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/device-certificates/1.1.1.104&quot;,
            &quot;generation&quot;: 3
        },
        {
            &quot;certificateId&quot;: &quot;172.17.0.2&quot;,
            &quot;machineId&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;,
            &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIC2jCCAcKgAwIBAgIEdCSYjzANBgkqhkiG9w0BAQUFADAvMS0wKwYDVQQDDCRh\nZGVjNDUwNi02NTZmLTRhZWUtYTk0YS0yNDE0ZWU2M2YzZWMwHhcNMTgxMDA3MTUz\nOTM3WhcNMjgxMDA1MTUzOTM3WjAvMS0wKwYDVQQDDCRhZGVjNDUwNi02NTZmLTRh\nZWUtYTk0YS0yNDE0ZWU2M2YzZWMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\nAoIBAQCxrTZ1xckBWr/4fKQeZsKr4L21CHnEO647aGTt+2RfcP54rVgwO6NdxiLb\ndhb7eZpIJxdOxQaRsEbFl7CKcdLRXm6BjmfBPeTOfOuuwGEgdA6IoelUVvMXZP0O\nRAXCeUK3Jg/u+cMT1BDpMzG3UD8f7eZJhZL01lOUi6DPD6dWvYVI6bBiAhuQXnEg\n6BMudHjK7LwC/ETSFUrUCzjxm6hSKJHqmZZvhUK4iLtHjRtFSbzpYAO3qq+culpw\nZE8GavATWdBLkbRL5leQ3XjbaK20rX/YuOv8IJsfCYJTbLg6UlfrgufgStqLK+Hs\nNl8YlkdU3K5lPAJMRaCwn197ePBPAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACvC\nCEjo5Nlqir80VAGvdyPIGLpuGHz5RLpojQMjwWV7OM4UiDHo/Ip6LOAxVDYcKmnR\n987aw/yoDJlUJS8DHyYI1M9GNPTxKD6uMl0I0sf3u+j1xbFjubkXdfNJkRpgx9+b\nQDAemrpQnDtGqxOec+3TwYE5QYT6QmO9WPmxRjjiTj/IJyrhgnEjYQEBkO13Y81h\nzjpO1GDKwzY63pe7oMKjlqZjDyyDjPpKPJ1LaY3RpqKspWWNSXjeGIzDydDq6O7j\nVoj2Ry4Nb65MtzO+J7Da4sc32RMJLzUzqENH+EVcU/PLo4CLYmAIufa/SkLMer7Z\nOG0X329pEySOjncK330=\n-----END CERTIFICATE-----\n&quot;,
            &quot;generation&quot;: 63,
            &quot;lastUpdateMicros&quot;: 1539013176534132,
            &quot;kind&quot;: &quot;shared:device-certificates:devicecertificatestate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/device-certificates/172.17.0.2&quot;
        }
    ],
    &quot;generation&quot;: 86,
    &quot;kind&quot;: &quot;shared:device-certificates:devicecertificatecollectionstate&quot;,
    &quot;lastUpdateMicros&quot;: 1539013176977087,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/device-certificates&quot;
}</code></pre><p>Using the API Service Gateway <code>machineId</code>, record the <code>certificateId</code> for the API Services Gateway certificate registed on the remote BIG-IP.</p>
<p><strong>Step 3. Using the TrustedProxy extension, remove the API Services Gateway certificate from your remote BIG-IP</strong></p>
<p>Augment the <code>uri</code> in the POST body to include the <code>certificateId</code> and change the method to <code>Delete</code>. This will issue a <code>DELETE</code> request through the trust to delete the API Services Gateway certificate.</p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/TrustProxy -d &#39;   
{
   &quot;method&quot;:&quot;Delete&quot;,
   &quot;uri&quot;: &quot;https://10.1.1.7:443/mgmt/shared/device-certificates/[Your API Services Gateway certificateId]&quot;
}&#39;|json_pp

{
    &quot;certificateId&quot;: &quot;172.17.0.2&quot;,
    &quot;machineId&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;,
    &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIC2jCCAcKgAwIBAgIEdCSYjzANBgkqhkiG9w0BAQUFADAvMS0wKwYDVQQDDCRh\nZGVjNDUwNi02NTZmLTRhZWUtYTk0YS0yNDE0ZWU2M2YzZWMwHhcNMTgxMDA3MTUz\nOTM3WhcNMjgxMDA1MTUzOTM3WjAvMS0wKwYDVQQDDCRhZGVjNDUwNi02NTZmLTRh\nZWUtYTk0YS0yNDE0ZWU2M2YzZWMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\nAoIBAQCxrTZ1xckBWr/4fKQeZsKr4L21CHnEO647aGTt+2RfcP54rVgwO6NdxiLb\ndhb7eZpIJxdOxQaRsEbFl7CKcdLRXm6BjmfBPeTOfOuuwGEgdA6IoelUVvMXZP0O\nRAXCeUK3Jg/u+cMT1BDpMzG3UD8f7eZJhZL01lOUi6DPD6dWvYVI6bBiAhuQXnEg\n6BMudHjK7LwC/ETSFUrUCzjxm6hSKJHqmZZvhUK4iLtHjRtFSbzpYAO3qq+culpw\nZE8GavATWdBLkbRL5leQ3XjbaK20rX/YuOv8IJsfCYJTbLg6UlfrgufgStqLK+Hs\nNl8YlkdU3K5lPAJMRaCwn197ePBPAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACvC\nCEjo5Nlqir80VAGvdyPIGLpuGHz5RLpojQMjwWV7OM4UiDHo/Ip6LOAxVDYcKmnR\n987aw/yoDJlUJS8DHyYI1M9GNPTxKD6uMl0I0sf3u+j1xbFjubkXdfNJkRpgx9+b\nQDAemrpQnDtGqxOec+3TwYE5QYT6QmO9WPmxRjjiTj/IJyrhgnEjYQEBkO13Y81h\nzjpO1GDKwzY63pe7oMKjlqZjDyyDjPpKPJ1LaY3RpqKspWWNSXjeGIzDydDq6O7j\nVoj2Ry4Nb65MtzO+J7Da4sc32RMJLzUzqENH+EVcU/PLo4CLYmAIufa/SkLMer7Z\nOG0X329pEySOjncK330=\n-----END CERTIFICATE-----\n&quot;,
    &quot;generation&quot;: 63,
    &quot;lastUpdateMicros&quot;: 1539013176534132,
    &quot;kind&quot;: &quot;shared:device-certificates:devicecertificatestate&quot;,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/device-certificates/172.17.0.2&quot;
}
</code></pre><p>If you attempt to use the trust at this point, the request will be signed by the API Servies Gateway, but the signature can not be confirmed on the remote BIG-IP. Any further attempts to make iControl REST calls to our remote BIG-IP will receive a <code>401 Unauthorized</code> response.</p>
<p><strong>Step 4. Remove the remote BIG-IP from the API Services Gateway device group</strong></p>
<p>Augment the device group URI with <code>/devices/</code>[your remote BIG-IP machineId] and issue a <code>DELETE</code> iControl REST request to the API Services Gateway.</p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X DELETE https://localhost:8443/mgmt/shared/resolver/device-groups/app1/devices/[Your remote BIG-IP machineId]|json_pp

{
    &quot;uuid&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
    &quot;deviceUri&quot;: &quot;https://10.1.1.7:443&quot;,
    &quot;machineId&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
    &quot;state&quot;: &quot;ACTIVE&quot;,
    &quot;address&quot;: &quot;10.1.1.7&quot;,
    &quot;httpsPort&quot;: 443,
    &quot;hostname&quot;: &quot;test-bigip1.sample.openstack.f5se.com&quot;,
    &quot;version&quot;: &quot;13.1.1&quot;,
    &quot;product&quot;: &quot;BIG-IP&quot;,
    &quot;platformMarketingName&quot;: &quot;BIG-IP Virtual Edition&quot;,
    &quot;edition&quot;: &quot;Final&quot;,
    &quot;build&quot;: &quot;0.0.4&quot;,
    &quot;restFrameworkVersion&quot;: &quot;13.1.1-0.0.4&quot;,
    &quot;managementAddress&quot;: &quot;192.168.245.105&quot;,
    &quot;mcpDeviceName&quot;: &quot;/Common/test-bigip1.novalocal&quot;,
    &quot;trustDomainGuid&quot;: &quot;f419bf5b-d194-4c68-96c0fa163ee2381c&quot;,
    &quot;properties&quot;: {
        &quot;shared:resolver:device-groups:discoverer&quot;: &quot;adec4506-656f-4aee-a94a-2414ee63f3ec&quot;
    },
    &quot;isClustered&quot;: false,
    &quot;isVirtual&quot;: true,
    &quot;groupName&quot;: &quot;app1&quot;,
    &quot;generation&quot;: 3,
    &quot;lastUpdateMicros&quot;: 1539013178608469,
    &quot;kind&quot;: &quot;shared:resolver:device-groups:restdeviceresolverdevicestate&quot;,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/resolver/device-groups/app1/devices/c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;
}</code></pre><p>Now that the device group entry for our remote BIG-IP has been removed, the TrustedProxy extension would not longer be able to resolve the trusted device to sign requests.</p>
<p><strong>Step 5. Query the remote BIG-IP <code>certificateId</code> from the API Services Gateway</strong></p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/device-certificates|json_pp

{
    &quot;items&quot;: [
        {
            &quot;certificateId&quot;: &quot;1.1.1.104&quot;,
            &quot;machineId&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
            &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIC2jCCAcKgAwIBAgIEGFbjgzANBgkqhkiG9w0BAQUFADAvMS0wKwYDVQQDDCRj\nNjFlMTM5NC0yNTBjLTQ1MWQtYTFjMi1mYzBmN2QxZmE5OWEwHhcNMTgwOTA1MTgy\nMzQ0WhcNMjgwOTAzMTgyMzQ0WjAvMS0wKwYDVQQDDCRjNjFlMTM5NC0yNTBjLTQ1\nMWQtYTFjMi1mYzBmN2QxZmE5OWEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\nAoIBAQDruU0PO02LbQKkRVYTz4AIq9t90YlRHKqj3jMWZ4mzbbKH0u0NCv3N5f4w\n4cbAQTp1UAi1wu71H6eLm8AVQw0sgTyhcVbSpSIoN2fD8a1RpbtLNpz7EjohPnMh\nTh0ooBnpwwXz0THs/dx/v1M97Dh8VSE8+q90ibJE4k259111GUyG1ZrlWkqAT1gD\n71zHOOICfcmNpL4eFNI18K3OZAZ7pxroQctRre2d19I6KpqiUwNFrNEQ002mu/WM\nMQrm8PrFvK4c93JZ3wTqcixIl+Xkgf8YHQv/tEqapsndMb+qIgQCRsvX192xQTsm\nnRFuVnihMpmjdC6v5gw8VP0CGK+fAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAG00\n9WWq36mVjNXknzHuoxd/pQOMZX9j3WBonPiTkvD9uXKlEtywEmTzJ+yagqUHBYjT\nQEOrNsc12huI40d5Y7Xr8/NCo6SQxxnyphpbiMI/DGaJLltSoogYRZzfr1Da/7k+\nQ+R9ITWV8aBvnAZ4yokIgkAwvSOILc3mIOy3Zfoja2SFNJPxPIpEAXilC71JrtVW\n+vSc6ezuKAXfzWbh2T3KNfEW9QZ7LDy4Auc4/P+vIVXffApk7ytJriJHXrV24RSq\nfsVP3GF2km0dkNMa5Zw3nq5RNRaosLa2MqMt/3xUfWUb8QSsTCAme0IEvgU0i0yo\nZU6oSQxXONf+2UI/8AI=\n-----END CERTIFICATE-----\n&quot;,
            &quot;generation&quot;: 1,
            &quot;lastUpdateMicros&quot;: 1539013178498948,
            &quot;kind&quot;: &quot;shared:device-certificates:devicecertificatestate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/device-certificates/1.1.1.104&quot;
        },
        {
            &quot;certificateId&quot;: &quot;172.17.0.2&quot;,
            &quot;machineId&quot;: &quot;2e626fe5-e362-4a6e-91e8-f3e5be8bd43a&quot;,
            &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIC2jCCAcKgAwIBAgIEdCSYjzANBgkqhkiG9w0BAQUFADAvMS0wKwYDVQQDDCRh\nZGVjNDUwNi02NTZmLTRhZWUtYTk0YS0yNDE0ZWU2M2YzZWMwHhcNMTgxMDA3MTUz\nOTM3WhcNMjgxMDA1MTUzOTM3WjAvMS0wKwYDVQQDDCRhZGVjNDUwNi02NTZmLTRh\nZWUtYTk0YS0yNDE0ZWU2M2YzZWMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\nAoIBAQCxrTZ1xckBWr/4fKQeZsKr4L21CHnEO647aGTt+2RfcP54rVgwO6NdxiLb\ndhb7eZpIJxdOxQaRsEbFl7CKcdLRXm6BjmfBPeTOfOuuwGEgdA6IoelUVvMXZP0O\nRAXCeUK3Jg/u+cMT1BDpMzG3UD8f7eZJhZL01lOUi6DPD6dWvYVI6bBiAhuQXnEg\n6BMudHjK7LwC/ETSFUrUCzjxm6hSKJHqmZZvhUK4iLtHjRtFSbzpYAO3qq+culpw\nZE8GavATWdBLkbRL5leQ3XjbaK20rX/YuOv8IJsfCYJTbLg6UlfrgufgStqLK+Hs\nNl8YlkdU3K5lPAJMRaCwn197ePBPAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACvC\nCEjo5Nlqir80VAGvdyPIGLpuGHz5RLpojQMjwWV7OM4UiDHo/Ip6LOAxVDYcKmnR\n987aw/yoDJlUJS8DHyYI1M9GNPTxKD6uMl0I0sf3u+j1xbFjubkXdfNJkRpgx9+b\nQDAemrpQnDtGqxOec+3TwYE5QYT6QmO9WPmxRjjiTj/IJyrhgnEjYQEBkO13Y81h\nzjpO1GDKwzY63pe7oMKjlqZjDyyDjPpKPJ1LaY3RpqKspWWNSXjeGIzDydDq6O7j\nVoj2Ry4Nb65MtzO+J7Da4sc32RMJLzUzqENH+EVcU/PLo4CLYmAIufa/SkLMer7Z\nOG0X329pEySOjncK330=\n-----END CERTIFICATE-----\n&quot;,
            &quot;generation&quot;: 42,
            &quot;lastUpdateMicros&quot;: 1539104375117269,
            &quot;kind&quot;: &quot;shared:device-certificates:devicecertificatestate&quot;,
            &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/device-certificates/172.17.0.2&quot;
        }
    ],
    &quot;generation&quot;: 43,
    &quot;kind&quot;: &quot;shared:device-certificates:devicecertificatecollectionstate&quot;,
    &quot;lastUpdateMicros&quot;: 1539104376350680,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/device-certificates&quot;
}</code></pre><p>Record the <code>certificateId</code> for the <code>machineId</code> matching your remote BIG-IP. </p>
<p><strong>Step 6. Remove the remote BIG-IP&#39;s certificate on the API Services Gateway</strong></p>
<p>Lastly we remove the remote BIG-IP&#39;s certificate from the Application Services Gateway. Augment the certificates URI with the <code>certificateId</code> for our remote BIG-IP and issue a <code>DELETE</code> iControl REST request on the Application Services Gateway.</p>
<p><strong>Use curl in the F5 Container Demonstration Device SSH session</strong></p>
<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X DELETE https://localhost:8443/mgmt/shared/device-certificates/[Your remote BIG-IP certificateId]|json_pp

{
    &quot;certificateId&quot;: &quot;1.1.1.104&quot;,
    &quot;machineId&quot;: &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
    &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIC2jCCAcKgAwIBAgIEGFbjgzANBgkqhkiG9w0BAQUFADAvMS0wKwYDVQQDDCRj\nNjFlMTM5NC0yNTBjLTQ1MWQtYTFjMi1mYzBmN2QxZmE5OWEwHhcNMTgwOTA1MTgy\nMzQ0WhcNMjgwOTAzMTgyMzQ0WjAvMS0wKwYDVQQDDCRjNjFlMTM5NC0yNTBjLTQ1\nMWQtYTFjMi1mYzBmN2QxZmE5OWEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\nAoIBAQDruU0PO02LbQKkRVYTz4AIq9t90YlRHKqj3jMWZ4mzbbKH0u0NCv3N5f4w\n4cbAQTp1UAi1wu71H6eLm8AVQw0sgTyhcVbSpSIoN2fD8a1RpbtLNpz7EjohPnMh\nTh0ooBnpwwXz0THs/dx/v1M97Dh8VSE8+q90ibJE4k259111GUyG1ZrlWkqAT1gD\n71zHOOICfcmNpL4eFNI18K3OZAZ7pxroQctRre2d19I6KpqiUwNFrNEQ002mu/WM\nMQrm8PrFvK4c93JZ3wTqcixIl+Xkgf8YHQv/tEqapsndMb+qIgQCRsvX192xQTsm\nnRFuVnihMpmjdC6v5gw8VP0CGK+fAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAG00\n9WWq36mVjNXknzHuoxd/pQOMZX9j3WBonPiTkvD9uXKlEtywEmTzJ+yagqUHBYjT\nQEOrNsc12huI40d5Y7Xr8/NCo6SQxxnyphpbiMI/DGaJLltSoogYRZzfr1Da/7k+\nQ+R9ITWV8aBvnAZ4yokIgkAwvSOILc3mIOy3Zfoja2SFNJPxPIpEAXilC71JrtVW\n+vSc6ezuKAXfzWbh2T3KNfEW9QZ7LDy4Auc4/P+vIVXffApk7ytJriJHXrV24RSq\nfsVP3GF2km0dkNMa5Zw3nq5RNRaosLa2MqMt/3xUfWUb8QSsTCAme0IEvgU0i0yo\nZU6oSQxXONf+2UI/8AI=\n-----END CERTIFICATE-----\n&quot;,
    &quot;generation&quot;: 1,
    &quot;lastUpdateMicros&quot;: 1539013178498948,
    &quot;kind&quot;: &quot;shared:device-certificates:devicecertificatestate&quot;,
    &quot;selfLink&quot;: &quot;https://localhost/mgmt/shared/device-certificates/1.1.1.104&quot;
}</code></pre><p>Now there is no vestage of our trust left.</p>
<p><strong>Note:</strong> You might be tempted to simply delete your container, thus removing the API Services Gateway. While you can do this, the remote BIG-IP will retain the trusted device certficate for the now deleted container. It is better to clean up the trust appropriately, or else delete both the container and the remote BIG-IP virtual machine.</p>
<p>If you desire, you can also delete the <code>app1</code> device group we created from your API Services Gateway. If you have gotten this far, you should have the hang of this by now. Just find the right iControl REST request to make to remove a device group and issue it against the API Services Gateway endpoint.</p>
<h3 id="exercise-8-designing-a-trusteddevices-icontrol-lx-extension-from-json-schema">Exercise #8 - Designing a TrustedDevices iControl LX Extension from JSON Schema</h3>
<p>Removing a trusted device from he API Services Gateway has a horrible user experience. Adding a trusted device seemed straight forward because iControl REST hid the concerns of the certificate exchange. However, the removal process was a mess we shouldn&#39;t be exposing. How do we fix that? </p>
<p><strong>iControl LX extension - for when your own product is too hard for everyone else to use!</strong></p>
<p>Let&#39;s add another iControl LX extension which make these complex iControl REST interactions with the API Services Gateway simple through a declaration.</p>
<p>In fact, let&#39;s go through the same design exercise we go through for all declarative iControl LX extensions like AS3! That will teach you the steps involved in growing ecosystem services. It will also aid in your understanding of what is going on behind the scenes when using F5 published declarative interfaces.</p>
<p>We will design a TrustedDevices iControl LX extension which will handle the lifecyle of device trusts for the API Services Gateway in a declarative fashion.</p>
<p>Here is a JSON schema for our declaration:</p>
<pre><code class="language-JSON">{
    &quot;definitions&quot;: {},
    &quot;$schema&quot;: &quot;&quot;,
    &quot;$id&quot;: &quot;/assets/schemas/asgtrusteddevices.json&quot;,
    &quot;type&quot;: &quot;object&quot;,
    &quot;title&quot;: &quot;Application Services Gateawy Trusted Devices Schema&quot;,
    &quot;description&quot;: &quot;Simple declarative schema to manage trusted devices for the F5 Application Services Gateway&quot;,
    &quot;required&quot;: [
        &quot;devices&quot;
    ],
    &quot;properties&quot;: {
        &quot;devices&quot;: {
            &quot;$id&quot;: &quot;#/properties/devices&quot;,
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Trusted Devices List&quot;,
            &quot;description&quot;: &quot;List of trusted devices which should be defined for the API Services Gateway&quot;,
            &quot;items&quot;: {
                &quot;$id&quot;: &quot;#/properties/devices/items&quot;,
                &quot;type&quot;: &quot;object&quot;,
                &quot;title&quot;: &quot;Trusted Device&quot;,
                &quot;description&quot;: &quot;Attributes need to define a trusted device&quot;,
                &quot;required&quot;: [
                    &quot;targetHost&quot;,
                    &quot;targetUsername&quot;,
                    &quot;targetPassphrase&quot;,
                    &quot;state&quot;
                ],
                &quot;properties&quot;: {
                    &quot;targetHost&quot;: {
                        &quot;$id&quot;: &quot;#/properties/devices/items/properties/targetHost&quot;,
                        &quot;type&quot;: &quot;string&quot;,
                        &quot;title&quot;: &quot;Target Host&quot;,
                        &quot;description&quot;: &quot;The iControl REST endpoint host for the remote BIG-IP&quot;,
                        &quot;default&quot;: &quot;&quot;,
                        &quot;examples&quot;: [
                            &quot;192.168.245.1&quot;
                        ],
                        &quot;pattern&quot;: &quot;^(.*)$&quot;
                    },
                    &quot;targetPort&quot;: {
                        &quot;$id&quot;: &quot;#/properties/devices/items/properties/targetPort&quot;,
                        &quot;type&quot;: &quot;integer&quot;,
                        &quot;title&quot;: &quot;Target Port&quot;,
                        &quot;description&quot;: &quot;The iControl REST endpoint port for the remote BIG-IP&quot;,
                        &quot;default&quot;: 443,
                        &quot;examples&quot;: [
                            443
                        ]
                    },
                    &quot;targetUsername&quot;: {
                        &quot;$id&quot;: &quot;#/properties/devices/items/properties/targetUsername&quot;,
                        &quot;type&quot;: &quot;string&quot;,
                        &quot;title&quot;: &quot;Target Username&quot;,
                        &quot;description&quot;: &quot;The username with Administrator role on the remote BIG-IP&quot;,
                        &quot;default&quot;: &quot;admin&quot;,
                        &quot;writeOnly&quot;: true,
                        &quot;examples&quot;: [
                            &quot;admin&quot;
                        ],
                        &quot;pattern&quot;: &quot;^(.*)$&quot;
                    },
                    &quot;targetPassphrase&quot;: {
                        &quot;$id&quot;: &quot;#/properties/devices/items/properties/targetPassphrase&quot;,
                        &quot;type&quot;: &quot;string&quot;,
                        &quot;title&quot;: &quot;Target Passphrase&quot;,
                        &quot;description&quot;: &quot;The passphrase for the user on the remote BIG-IP&quot;,
                        &quot;default&quot;: &quot;admin&quot;,
                        &quot;writeOnly&quot;: true,
                        &quot;examples&quot;: [
                            &quot;admin&quot;
                        ],
                        &quot;pattern&quot;: &quot;^(.*)$&quot;
                    },
                    &quot;state&quot;: {
                        &quot;$id&quot;: &quot;#/properties/devices/items/properties/state&quot;,
                        &quot;type&quot;: &quot;string&quot;,
                        &quot;title&quot;: &quot;State of the remote trusted BIG-IP device&quot;,
                        &quot;description&quot;: &quot;State of the remote BIG-IP in the trusted device group&quot;,
                        &quot;default&quot;: &quot;UNKNOWN&quot;,
                        &quot;readOnlly&quot;: true,
                        &quot;examples&quot;: [
                            &quot;PENDING&quot;,
                            &quot;ACTIVE&quot;,
                            &quot;FAILED&quot;
                        ],
                        &quot;pattern&quot;: &quot;^(.*)$&quot;
                    }
                }
            }
        }
    }
}</code></pre>
<p>Don&#39;t feak out.. You don&#39;t need to understand anything more than the fact we are using a standard called <em>JSON schema</em> to define the interactions of our proposed API. You can build your own JSON schemas and learn more about the standard at <a href="https://www.jsonschema.net/">jsonschema.net</a>.</p>
<p>We&#39;re skipping a bunch of useful things in our schema, like proper validation patterns and limits, but we are showing this brief example to teach you how to simplify user experience through declaration. The schema looks complicated, but it boils down towards a goal of issuing a simple <code>POST</code> declaration like this:</p>
<pre><code>{
    &quot;devices&quot;: [
      {
        &quot;targetHost&quot;: &quot;10.1.1.7&quot;,
        &quot;targetPort&quot;: 443,
        &quot;targetUsername&quot;: &quot;admin&quot;,
        &quot;targetPassphrase&quot;: &quot;admin&quot;
      },
      {
        &quot;targetHost&quot;: &quot;10.1.1.6&quot;,
        &quot;targetPort&quot;: 443,
        &quot;targetUsername&quot;: &quot;admin&quot;,
        &quot;targetPassphrase&quot;: &quot;admin&quot;
      }
    ]
}</code></pre><p>Let&#39;s define our iControl REST endpoint for our extension to be: <code>/mgmt/shared/TrustedDevices</code>.</p>
<p>This is a much simplier API then AS3, so we will only support <code>GET</code> and <code>POST</code> requests with complete declarations. We won&#39;t support additional URL namespaces or <code>POST</code> <code>action</code> attributes like AS3 does. We won&#39;t implement and fancy ODATA or graphql filtering complications. All that stuff can be added in another container which frontends interactions with the Application Services Gateway. Remember, <em>we&#39;re decomposing</em> to be cloud ready.</p>
<p>Notice that our <code>targetUsername</code> and <code>targetPassword</code> attributes are <code>writeOnly</code>. That means they should only be present in <code>POST</code> requests. Our <code>state</code> attribute is <code>readOnly</code>, so it can not be set in a <code>POST</code> request, but will be present in the responses to <code>GET</code> or <code>POST</code> requests. </p>
<p>Assuming we made the previous declaration in a <code>POST</code> request, let&#39;s have subsequest <code>GET</code> requests yield something like this:</p>
<pre><code>{
    &quot;devices&quot;: [
      {
        &quot;targetHost&quot;: &quot;10.1.1.7&quot;,
        &quot;targetPort&quot;: 443,
        &quot;state&quot;: &quot;ACTIVE&quot;
      },
      {
        &quot;targetHost&quot;: &quot;10.1.1.6&quot;,
        &quot;targetPort&quot;: 443,
        &quot;state&quot;: &quot;ACTIVE&quot;
      }
    ]
}</code></pre><p>Notice the <code>writeOnly</code> attributes are missing, but the <code>readOnly</code> attribute is present. We should <em>NEVER</em> see our TMOS credentials every again. We can gain <em>separation of concerns</em> as part of our user experience!</p>
<p>For a simplified user interaction to remove a trusted device, let&#39;s have the user simply remove it from their declaration. Assuming we made the previous declaration, to remove the <code>targetHost</code> 10.1.1.6, but retain <code>targetHost</code> 10.1.1.7, we just <code>POST</code> this declaration.</p>
<pre><code>{
    &quot;devices&quot;: [
      {
        &quot;targetHost&quot;: &quot;10.1.1.7&quot;
      }
    ]
}</code></pre><p>They shouldn&#39;t need to give us TMOS credentials just to retain a trusted device, so let&#39;s not make them supply those. Again, we are worried about user experience in our example.</p>
<p>That seems to give us everything we need, but keep the user experience simple. Fisrt you issue <code>GET</code> requests to see what trusted device are currently defined. Then you issue <code>POST</code> requests declarations specifying which trusted devices to add or retain. If you want to remove all device trusts,just <code>POST</code> an empty <code>devices</code> list like this:</p>
<pre><code>{
  &quot;devices&quot;: []
}</code></pre><p>In our user experience, we removed the concern for the device group entirely. That is the user experience we decided to implement. If you don&#39;t like that, change it. You don&#39;t need to wait for a new TMOS release to get a new API user experience. You don&#39;t have to wait for a new TMOS release to remove TMOS concerns from your API users. There is no purchase cost for the Application Service Gateway, so start as many of them as you want. Experiment. Refine. Test. Deploy. That&#39;s cloud ready.</p>
<p>This is just an example of defining a particular user experience and then creating a schema and an iControl LX extension to implement our declarative API. Do you think you could do this? Most of our engineers didn&#39;t think they would ever write an iRule at one point, but look at us now.</p>
<p><strong>Note:</strong> If your desired user experience includes interaction with non-TMOS services, you should use the API Services Gateway <em>ONLY</em> for the TMOS interaction. The other service interactions should have their own containerized endpoints using frameworks and libraries which make sense for those systems. That&#39;s cloud ready. That&#39;s micro-services. If you find you are making iControl REST calls and using calls to another vendor&#39;s APIs in the same iControl LX extension, you did it wrong.</p>
<p>We&#39;ve written the iControl LX extension which implements this user experience for you. If you are interested, <a href="/icontrollx/TrustedDevices/src/nodejs/TrustedDevicesWorker.js">here is the source code</a>. The RPM package file for this extension can be downloaded to the F5 Container Demonstration Virtual Device just like the TrustProxy RPM file.</p>
<p>To test your skills, see if you can:</p>
<ul>
<li>Download the TrustedDevices RPM install package to the F5 Container Demonstration Virtual Device</li>
<li>Upload the RPM file into the Application Services Gateway</li>
<li>Install the DeviceTrustGroup iControl LX extension </li>
<li>Issue a declaration to the <code>/mgmt/shared/TrustedDevices</code> endpoint to add and remove truted BIG-IPs</li>
</ul>
<p>You&#39;ve already done exercises for each of those step associated with the TrustedProxy extension. Just review those exercises and do the same for the DeviceTrustGroup extension. Here are some hints:</p>
<p><strong>Step 1. Download the TrustedDevices RPM install package to the F5 Container Demonstration Virtual Device</strong></p>
<div id='asg-download-trust-device-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -O http://localhost/icontrollx/TrustedDevices/build/RPMS/noarch/TrustedDevices-1.0.0-0001.noarch.rpm</code></pre><p><strong>Step 2. Upload the RPM file into the Application Services Gateway</strong></p>
<div id='asg-upload-trust-device-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ filepath=&#39;/home/ubuntu/TrustedDevices-1.0.0-0001.noarch.rpm&#39;
ubuntu@ip-10-1-1-8:~$ filename=$(basename $filepath)
ubuntu@ip-10-1-1-8:~$ rangeheader=&quot;Content-Range:0-&quot;$(expr $(stat -c &#39;%s&#39; $filename) - 1)&quot;/&quot;$(stat -c &#39;%s&#39; $filename)
ubuntu@ip-10-1-1-8:~$ curl -k --header &quot;Content-Type:application/octet-stream&quot; --header $rangeheader -v --data-binary @${filepath} https://localhost:8443/mgmt/shared/file-transfer/uploads/${filename}</code></pre><p><strong>Step 3. Install the TrustedDevices iControl LX extension</strong></p>
<div id='asg-install-trust-device-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d &#39;{ 
    &quot;operation&quot;:&quot;INSTALL&quot;,
    &quot;packageFilePath&quot;: &quot;/var/config/rest/downloads/TrustedDevices-1.0.0-0001.noarch.rpm&quot;
}&#39;|json_pp

{
   &quot;lastUpdateMicros&quot; : 1539100701682596,
   &quot;generation&quot; : 1,
   &quot;ownerMachineId&quot; : &quot;d4b0973a-dea3-4eb9-a281-f6378ed5cfc8&quot;,
   &quot;packageFilePath&quot; : &quot;/var/config/rest/downloads/TrustedDevices-1.0.0-0001.noarch.rpm&quot;,
   &quot;status&quot; : &quot;CREATED&quot;,
   &quot;kind&quot; : &quot;shared:iapp:package-management-tasks:iapppackagemanagementtaskstate&quot;,
   &quot;selfLink&quot; : &quot;https://localhost/mgmt/shared/iapp/package-management-tasks/863d509e-a246-4361-81ca-43e9b4f19968&quot;,
   &quot;id&quot; : &quot;863d509e-a246-4361-81ca-43e9b4f19968&quot;,
   &quot;operation&quot; : &quot;INSTALL&quot;
}</code></pre><p><strong>Step 4. Issue requests to our TrustedDevices iControl LX extension</strong></p>
<p>You should play around with your new TrustedDevices iControl LX extension and see how easy it is to add and remove trusted devices now. That&#39;s the whole point. We took something complex and made it simpler through declarations.</p>
<p>Get the devices which are currently trusted by the API Services Gateway</p>
<div id='asg-get-trust-device-command'>

</div> 

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/TrustedDevices|json_pp
{
    &quot;devices&quot;: [
        {
            &quot;targetHost&quot;: &quot;10.1.1.6&quot;,
            &quot;targetPort&quot;: 443,
            &quot;state&quot;: &quot;ACTIVE&quot;
        },
        {
            &quot;targetHost&quot;: &quot;10.1.1.7&quot;,
            &quot;targetPort&quot;: 443,
            &quot;state&quot;: &quot;ACTIVE&quot;
        }
    ]
}</code></pre><p>Remove all the trusted devices from the API Services Gateway.</p>
<div id='asg-remove-trust-device-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST -d &#39;{ &quot;devices&quot;: [] }&#39; https://localhost:8443/mgmt/shared/TrustedDevices|json_pp
{
    &quot;devices&quot;: []
}</code></pre><p>Add a deivce trust.</p>
<div id='asg-add-trust-device-command'>

</div> 

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST -d &#39;{ &quot;devices&quot;: [ &quot;targetHost&quot;: &quot;10.1.1.7&quot;, &quot;targetUsername&quot;: &quot;admin&quot;, &quot;targetPassphrase&quot;:&quot;admin&quot; ] }&#39; https://localhost:8443/mgmt/shared/TrustedDevices|json_pp
{
    &quot;devices&quot;: [
        {
            &quot;targetHost&quot;: &quot;10.1.1.7&quot;,
            &quot;targetPort&quot;: 443,
            &quot;state&quot;: &quot;ACTIVE&quot;
        }
    ]
}</code></pre><p><strong>Note:</strong> We used JSON schema because AS3 uses JSON schema. There are other schema standards which are becoming better accepted than JSON schema. Look at <a href="https://www.openapis.org/">OpenAPI</a>. We&#39;ll use an OpenAPI generated interactive UI to avoid all this <code>curl</code> cnt-n-paste and SSH sessions in future exercises.</p>
<p>If you want to see more complex JSON schemas, the clouddocs that were generated from AS3&#39;s JSON schema files can be viewed here:</p>
<p><a href="https://clouddocs.f5.com/products/extensions/f5-appsvcs-extension/3/refguide/schema-reference.html">AS3 Schemas Documentation</a></p>
<p>Appreciate that starting with well defined schemas for our API contracts leads to better code, better testing, and documentation.</p>
<h3 id="exercise-9-using-the-trustedproxy-icontrol-lx-extension-as-a-token-service">Exercise #9 - Using the TrustedProxy iControl LX Extension As A Token Service</h3>
<p>Turns out the API Services Gateway isn&#39;t perfect. As a full proxy to trusted devices it works very well for <em>most</em> iControl REST requests. However there are situations where having direct access to trusted BIG-IP devices is desirable:</p>
<ul>
<li><p>When an iControl REST request requires any <code>Content-Type</code> other then <code>application/json</code>, for example where content streaming is required. You experienced this using <code>curl</code> to upload an iControl LX extension RPM package file to the API Services Gateway. Direct access to HTTP headers was required to interact with the IControl REST FileWorker to stream our file upload to the device.</p>
</li>
<li><p>When the performance or security topology precludes the use of the API Services Gateway as a full proxy.    </p>
</li>
<li><p>When migrating or decomposing an existing iControl REST application into a mciro services architect. It might be nice to retain the same tested iControl REST request workflows.</p>
</li>
</ul>
<p><em>I thought we could only proxy requests through the trusted API Services Gateway. How can we still remove the concerns of TMOS authentication and roles authorization from our solution in these situations?</em>   </p>
<p>We <em>expose the internal</em> iControl REST signature mechanism the API Service Gateway is using to external clients. We can build an iControl LX extension which exposes these internal TMOS iControl REST APIs. This extension won&#39;t be a fully declarative interface, rather simply a way to expose an internal service or process to clients.</p>
<p><strong><em>Note:</em> iControl LX extensions can be use to expose important components of F5 technology which are not readily exposed through our REST APIs. This includes security token generation, dynamic routing configuration, and other non iControl REST exposed system applications. You can utilize iControl LX extension to expose internals of any platform which supports the iControl LX framework. This includes BIG-IP devices and the API Services Gatway.</strong>   </p>
<p>Let&#39;s not write a totally new iControl LX extension, let&#39;s just extend our existing TrustedProxy extension to support <code>GET</code> requests for security token retrieval. <strong>We lied to you  before... Your TrustedProxy iControl LX extension already supports this.  Sorry to fool you.. not really.</strong></p>
<p><img src="./assets/images/f5-api-services-gateway-proxy-or-token.png" alt="Established Trust through iControl LX extensions in two ways"></p>
<p>The internal mechanism used by the API Service Gateway to sign proxied requests does so by adding two query parameters to all targeted iControl REST requests. The parameters indentify the API Services Gateway to the remote TMOS device and present the signed token. Here is an example of what the augmented query parameters look like: </p>
<pre><code>?em_server_ip=172.17.0.2&amp;em_server_auth_token=jcV3CpJaECUop%2FGd2cnfGH%2FrTgFtJsq7DEXQeOuu%2B1mf137o7li02Bss31vJl3Wec3siMJLkPMUZIOwCMLtvNZunf9vT9A3udImoyuW%2FVxXClqDZUz50sQ8Fs6iPvdw4O8Nlha3dPidOyvf51fLWCER0HJgUH3Yd6RQrKP7oNd1T7OyD8kPunaSIyjXTgmirBYpl%2FC96f4Ofc2osgcA4vtT1sgampzOpKwgyptX7SUhXjkQZCEHpbOUGWBxCaqIvgLW30krRQM%2BFtJyfh41c%2FSp%2F5gOEMTSzyF9fmTUdkQ6NiJxBdff%2FuR7KW9QULzHusM0VDn1gZn2lvAkB0fh0ZQ%3D%3D</code></pre><p>Let&#39;s make a <code>GET</code> request to our TrustedProxy iControl LX extension to get an our signed tokens for each of our trusted devices.  </p>
<p><strong>Step 1. Get tokens for all your trusted devices</strong></p>
<div id='asg-get-tokens'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/TrustedProxy|json_pp  
{
    &quot;172.17.0.2&quot;: &quot;{\&quot;address\&quot;:\&quot;172.17.0.2\&quot;,\&quot;queryParam\&quot;:\&quot;em_server_ip=172.17.0.2&amp;em_server_auth_token=jcV3CpJaECUop%2FGd2cnfGH%2FrTgFtJsq7DEXQeOuu%2B1mf137o7li02Bss31vJl3Wec3siMJLkPMUZIOwCMLtvNZunf9vT9A3udImoyuW%2FVxXClqDZUz50sQ8Fs6iPvdw4O8Nlha3dPidOyvf51fLWCER0HJgUH3Yd6RQrKP7oNd1T7OyD8kPunaSIyjXTgmirBYpl%2FC96f4Ofc2osgcA4vtT1sgampzOpKwgyptX7SUhXjkQZCEHpbOUGWBxCaqIvgLW30krRQM%2BFtJyfh41c%2FSp%2F5gOEMTSzyF9fmTUdkQ6NiJxBdff%2FuR7KW9QULzHusM0VDn1gZn2lvAkB0fh0ZQ%3D%3D\&quot;,\&quot;timestamp\&quot;:1541175720288}&quot;,
    &quot;10.1.1.6&quot;: &quot;{\&quot;address\&quot;:\&quot;10.1.1.6\&quot;,\&quot;queryParam\&quot;:\&quot;em_server_ip=172.17.0.2&amp;em_server_auth_token=jcV3CpJaECUop%2FGd2cnfGH%2FrTgFtJsq7DEXQeOuu%2B1mf137o7li02Bss31vJl3Wec3siMJLkPMUZIOwCMLtvNZunf9vT9A3udImoyuW%2FVxXClqDZUz50sQ8Fs6iPvdw4O8Nlha3dPidOyvf51fLWCER0HJgUH3Yd6RQrKP7oNd1T7OyD8kPunaSIyjXTgmirBYpl%2FC96f4Ofc2osgcA4vtT1sgampzOpKwgyptX7SUhXjkQZCEHpbOUGWBxCaqIvgLW30krRQM%2BFtJyfh41c%2FSp%2F5gOEMTSzyF9fmTUdkQ6NiJxBdff%2FuR7KW9QULzHusM0VDn1gZn2lvAkB0fh0ZQ%3D%3D\&quot;,\&quot;timestamp\&quot;:1541175720299}&quot;,
    &quot;10.1.1.7&quot;: &quot;{\&quot;address\&quot;:\&quot;10.1.1.7\&quot;,\&quot;queryParam\&quot;:\&quot;em_server_ip=172.17.0.2&amp;em_server_auth_token=jcV3CpJaECUop%2FGd2cnfGH%2FrTgFtJsq7DEXQeOuu%2B1mf137o7li02Bss31vJl3Wec3siMJLkPMUZIOwCMLtvNZunf9vT9A3udImoyuW%2FVxXClqDZUz50sQ8Fs6iPvdw4O8Nlha3dPidOyvf51fLWCER0HJgUH3Yd6RQrKP7oNd1T7OyD8kPunaSIyjXTgmirBYpl%2FC96f4Ofc2osgcA4vtT1sgampzOpKwgyptX7SUhXjkQZCEHpbOUGWBxCaqIvgLW30krRQM%2BFtJyfh41c%2FSp%2F5gOEMTSzyF9fmTUdkQ6NiJxBdff%2FuR7KW9QULzHusM0VDn1gZn2lvAkB0fh0ZQ%3D%3D\&quot;,\&quot;timestamp\&quot;:1541175720309}&quot;
}</code></pre><p>Our API Service Gateway token is also included in the response, even though there is no security on our API Services Gateway by default. </p>
<p>If you followed the directions to enable Apache to enforce HTTP BASIC authentication for the API Service Gateway, you could build a micro service container which requires credentials to access the API Services Gateway, issue requests to the TrustedProxy iControl LX extension for tokens, and then returns those tokens to clients. Effectly building an F5 only secure token service container.</p>
<p>We&#39;ll see in a later example that completely removing direct access to any container which has the API Services Gateway services is a much easier way to secure things in our modern containerized world.</p>
<p>The returned token objects from our TrustedProxy iControl LX extension have three attributes:</p>
<hr>
<table>
<thead>
<tr>
<th align="left">TrustedProxy GET token attributes</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">address</td>
<td align="left">The trusted address attribute remote devices use to identify the API Service Gateway.</td>
</tr>
<tr>
<td align="left">queryParam</td>
<td align="left">The iControl REST query parameters to add to establish trust with remote devices.</td>
</tr>
<tr>
<td align="left">timestamp</td>
<td align="left">The Unix epoc timestamp indicating when the token lifetime. The token in good for 10 minutes.</td>
</tr>
</tbody></table>
<hr>
<p>Pick one of your trusted devices and see if the security token indeed works. You can do this by:</p>
<p>1) Using curl to retrieve a token and storing it in an environment variable. 
2) Issuing an iControl REST request directly to a trusted BIG-iP adding the token query parameters to your request URL.</p>
<p><strong>Step 2. Make an iControl Rest request directly to a trusted device using our retrieved token (query parameters)</strong></p>
<div id='asg-use-token'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ token=&quot;em_server_ip=172.17.0.2&amp;em_server_auth_token=jcV3CpJaECUop%2FGd2cnfGH%2FrTgFtJsq7DEXQeOuu%2B1mf137o7li02Bss31vJl3Wec3siMJLkPMUZIOwCMLtvNZunf9vT9A3udImoyuW%2FVxXClqDZUz50sQ8Fs6iPvdw4O8Nlha3dPidOyvf51fLWCER0HJgUH3Yd6RQrKP7oNd1T7OyD8kPunaSIyjXTgmirBYpl%2FC96f4Ofc2osgcA4vtT1sgampzOpKwgyptX7SUhXjkQZCEHpbOUGWBxCaqIvgLW30krRQM%2BFtJyfh41c%2FSp%2F5gOEMTSzyF9fmTUdkQ6NiJxBdff%2FuR7KW9QULzHusM0VDn1gZn2lvAkB0fh0ZQ%3D%3D&quot;

ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://10.1.1.7:443/mgmt/shared/identified-devices/config/device-info?$token|json_pp
{
   &quot;slots&quot; : [
      {
         &quot;build&quot; : &quot;0.0.4&quot;,
         &quot;volume&quot; : &quot;HD1.1&quot;,
         &quot;version&quot; : &quot;13.1.1&quot;,
         &quot;isActive&quot; : true,
         &quot;product&quot; : &quot;BIG-IP&quot;
      }
   ],
   &quot;isVirtual&quot; : true,
   &quot;hostname&quot; : &quot;test-bigip1.sample.openstack.f5se.com&quot;,
   &quot;kind&quot; : &quot;shared:resolver:device-groups:deviceinfostate&quot;,
   &quot;version&quot; : &quot;13.1.1&quot;,
   &quot;license&quot; : {
      &quot;registrationKey&quot; : &quot;XJZUM-URYVS-NCOWS-JZTOY-UDDFJMK&quot;,
      &quot;generation&quot; : 0,
      &quot;licenseEndDateTime&quot; : &quot;2018-12-08T00:00:00-08:00&quot;,
      &quot;lastUpdateMicros&quot; : 1541082238262665,
      &quot;activeModules&quot; : [
         &quot;APM, Base, VE GBB (500 CCU, 2500 Access Sessions)|VWBUMMZ-RGIKIGC|Anti-Virus Checks|Base Endpoint Security Checks|Firewall Checks|Network Access|Secure Virtual Keyboard|APM, Web Application|Machine Certificate Checks|Protected Workspace|Remote Desktop|App Tunnel&quot;,
         &quot;Best Bundle, VE-10G|PYNLMVQ-HOAWSAA|SSL, Forward Proxy, VE|DNS and GTM (250 QPS), VE|Advanced Protocols, VE|Rate Shaping|DNSSEC|GTM Licensed Objects, Unlimited|DNS Licensed Objects, Unlimited|DNS Rate Fallback, 250K|GTM Rate Fallback, 250K|GTM Rate, 250K|DNS Rate Limit, 250K QPS|ASM, VE|DNS-GTM, Base, 10Gbps|SSL, VE|Max Compression, VE|AFM, VE|Routing Bundle, VE|PSM, VE|VE, Carrier Grade NAT (AFM ONLY)&quot;,
         &quot;PEM, ADD-VE, 5G|WBDKAFW-JKOCDDT&quot;
      ]
   },
   &quot;restFrameworkVersion&quot; : &quot;13.1.1-0.0.4&quot;,
   &quot;interfaces&quot; : [
      &quot;mgmt&quot;,
      &quot;1.2&quot;,
      &quot;1.1&quot;
   ],
   &quot;address&quot; : &quot;1.1.1.104&quot;,
   &quot;trustDomainGuid&quot; : &quot;f419bf5b-d194-4c68-96c0fa163ee2381c&quot;,
   &quot;chassisSerialNumber&quot; : &quot;ec16fd8e-de21-0c48-b832af021c9b&quot;,
   &quot;hostMac&quot; : &quot;FA:16:3E:E2:38:1C&quot;,
   &quot;baseMac&quot; : &quot;FA:16:3E:E2:38:1C&quot;,
   &quot;isIControlRestSupported&quot; : true,
   &quot;build&quot; : &quot;0.0.4&quot;,
   &quot;cpu&quot; : &quot;Intel Core Processor (Skylake, IBRS)&quot;,
   &quot;machineId&quot; : &quot;c61e1394-250c-451d-a1c2-fc0f7d1fa99a&quot;,
   &quot;managementAddress&quot; : &quot;192.168.245.105&quot;,
   &quot;time&quot; : 1541176902822,
   &quot;edition&quot; : &quot;Final&quot;,
   &quot;physicalMemory&quot; : 1984,
   &quot;isClustered&quot; : false,
   &quot;generation&quot; : 0,
   &quot;lastUpdateMicros&quot; : 0,
   &quot;platformMarketingName&quot; : &quot;BIG-IP Virtual Edition&quot;,
   &quot;product&quot; : &quot;BIG-IP&quot;,
   &quot;halUuid&quot; : &quot;ec16fd8e-de21-0c48-91c8-b832af021c9b&quot;,
   &quot;selfLink&quot; : &quot;https://localhost/mgmt/shared/identified-devices/config/device-info&quot;,
   &quot;platform&quot; : &quot;Z100&quot;,
   &quot;mcpDeviceName&quot; : &quot;/Common/test-bigip1.novalocal&quot;,
   &quot;icrdPort&quot; : 8100
}
</code></pre><p><strong>Wow! Direct trusted access to BIG-IPs.</strong> </p>
<p>Don&#39;t forget to get new tokens before your 10 minutes expire. Otherwise you will get the same <code>401 Unauthorized</code> response as if you had no credentials.</p>
<h3 id="exercise-10-trustedextensions-icontrol-lx-extension-on-the-api-services-gateway">Exercise #10 - TrustedExtensions iControl LX Extension on the API Services Gateway</h3>
<p>We can all agree that the process to install an iControl LX extension is too complex. </p>
<ol>
<li>Download a structured RPM package file to something that has access to your target.</li>
<li>Use the iControl REST streaming FileWorker to upload your RPM file to the target device.</li>
<li>Issue an install task for your RPM package file.</li>
<li>Query your installation process until the task completes.</li>
</ol>
<p>It should be easier. By now you should know how we are going to fix this. You guessed it, we are going to create another iControl LX extension. This inception extension is going to install iControl LX extensions.</p>
<p>A simple <em>synchronous</em> worker, which takes a URL to your RPM, <code>http:</code>, <code>https:</code>, or <code>file:</code>, and installs it would be nice. If our extension RPM files are so big they can&#39;t upload and go through the <em>asynchronous</em> install tasks before our single request times out, fine, go back to the multi-step tasked based workflow.</p>
<p>Let&#39;s sprink in some knowledge of the API Service Gateway&#39;s trusted devices. All we should need to get from the user is a <code>targetHost</code> and a <code>url</code> to the RPM package file. That&#39;s really simple.</p>
<p>We&#39;re not going to take the time to generate a schema and create a full declarative workflow, though we could (and should). </p>
<p>So far our iControl LX examples have largely forced a restrict RESTful lifecycle. That makes sense when we are forcing a rigid declarative API contract. Let&#39;s loose things up a bit and allow the iControl LX user to play with query variables in <code>GET</code>,<code>POST</code>,<code>PUT</code>,and <code>DELETE</code> requests.</p>
<p><strong><em>Note: Somewhere the iControl REST architects just fainted. Do you know how much grief they had figuring out how to support basic tasks in TMOS which weren&#39;t RESTful. Take a big cleansing breath. Let it go! If we are creating a simple little app like this, just make the user experience what you want. For more critical operational tasks, full declarative interfaces save money. For quick fixes to bad API workflows, like this one, just simplify everyone&#39;s life and move on.</em></strong> </p>
<p>We&#39;ll have two simple required inputs, one optional input.</p>
<hr>
<table>
<thead>
<tr>
<th align="left">TrustedExtensions parameters</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">targetHost</td>
<td align="left">The trusted device to install the extension.</td>
</tr>
<tr>
<td align="left">targetPort (optional)</td>
<td align="left">The TCP port for the iControl REST endpoints.</td>
</tr>
<tr>
<td align="left">url</td>
<td align="left">The <code>http:</code>, <code>https:</code>, or <code>file:</code> URL of the extension RPM package file.</td>
</tr>
</tbody></table>
<hr>
<p>We&#39;ll collect our inputs as query parameters for:</p>
<ul>
<li><code>GET</code> requests to query what extensions are installed on a targeted device. </li>
<li><code>POST</code> requests to install an extension on a trusted device.</li>
<li><code>PUT</code> requests to uninstall and reinstall the extension on a trusted device.</li>
<li><code>DELETE</code> requests to uninstall an extension on a trusted device.</li>
</ul>
<p><strong>Note:</strong> You will still need a request body for <code>PUT</code> and <code>POST</code> requests. That&#39;s HTTP. But we can make it an empty JSON object <code>{ }</code> or a JSON object defining each of the parameters, for instance, one like this:</p>
<pre><code>POST /mgmt/shared/TrustedExtensions
{ 
     &quot;targetHost&quot;: &quot;10.1.1.7&quot;,
     &quot;targetPort&quot;: 443,
     &quot;url&quot;: &quot;https://github.com/F5Networks/f5-appsvcs-extension/releases/download/v3.5.0/f5-appsvcs-3.5.0-3.noarch.rpm&quot;
}</code></pre><p>Either way, the user can still use the query parameters if you want. This is about making things easy. So this works:</p>
<pre><code>POST /mgmt/shared/TrustedExtensions?targetHost=10.1.1.7targetPort=443&amp;url=&quot;https://github.com/F5Networks/f5-appsvcs-extension/releases/download/v3.5.0/f5-appsvcs-3.5.0-3.noarch.rpm&quot;
{ }</code></pre><p>Just for fun we&#39;ll make it smart enough to understand that a <code>targetHost</code>,<code>targetPort</code>, defined as <code>localhost</code> means to manage the extensions on the API Services Gateway itself! Inception indeed! However we&#39;re going to learn a big inception with this idea. We don&#39;t care, we&#39;re doing it anyway! Like Lionel Ritchie says.. <em>&#39;That why I&#39;m easy..&#39;</em> Exception in use cases be damned.. keep going!</p>
<p>Of course we&#39;ve written this example for you. If you are interested, <a href="/icontrollx/TrustedExtensions/src/nodejs/TrustedExtensionsWorker.js">here is the source code</a>.</p>
<p>Let&#39;s follow the manual steps for the last time to install our &#39;easy button&#39; for iControl LX extension installation.</p>
<p><strong>Step 1. Download the TrustedDevices RPM install package to the F5 Container Demonstration Virtual Device</strong></p>
<div id='asg-download-trust-extension-command'>

</div>


<pre><code>ubuntu@ip-10-1-1-8:~$ curl -O http://localhost/icontrollx/TrustedExtensions/build/RPMS/noarch/TrustedExtensions-1.0.0-0001.noarch.rpm</code></pre><p><strong>Step 2. Upload the RPM file into the Application Services Gateway</strong></p>
<div id='asg-upload-trust-extension-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ filepath=&#39;/home/ubuntu/TrustedExtensions-1.0.0-0001.noarch.rpm&#39;
ubuntu@ip-10-1-1-8:~$ filename=$(basename $filepath)
ubuntu@ip-10-1-1-8:~$ rangeheader=&quot;Content-Range:0-&quot;$(expr $(stat -c &#39;%s&#39; $filename) - 1)&quot;/&quot;$(stat -c &#39;%s&#39; $filename)
ubuntu@ip-10-1-1-8:~$ curl -k --header &quot;Content-Type:application/octet-stream&quot; --header $rangeheader -v --data-binary @${filepath} https://localhost:8443/mgmt/shared/file-transfer/uploads/${filename}</code></pre><p><strong>Step 3. Install the TrustedDevices iControl LX extension</strong></p>
<div id='asg-install-trust-extension-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; -X POST https://localhost:8443/mgmt/shared/iapp/package-management-tasks -d &#39;{ 
    &quot;operation&quot;:&quot;INSTALL&quot;,
    &quot;packageFilePath&quot;: &quot;/var/config/rest/downloads/TrustedExtensions-1.0.0-0001.noarch.rpm&quot;
}&#39;|json_pp

{
   &quot;lastUpdateMicros&quot; : 1539100701682596,
   &quot;generation&quot; : 1,
   &quot;ownerMachineId&quot; : &quot;d4b0973a-dea3-4eb9-a281-f6378ed5cfc8&quot;,
   &quot;packageFilePath&quot; : &quot;/var/config/rest/downloads/TrustedExtensions-1.0.0-0001.noarch.rpm&quot;,
   &quot;status&quot; : &quot;CREATED&quot;,
   &quot;kind&quot; : &quot;shared:iapp:package-management-tasks:iapppackagemanagementtaskstate&quot;,
   &quot;selfLink&quot; : &quot;https://localhost/mgmt/shared/iapp/package-management-tasks/8e1a6d03-0ffb-43bd-86a4-c4801fe43d36&quot;,
   &quot;id&quot; : &quot;8e1a6d03-0ffb-43bd-86a4-c4801fe43d36&quot;,
   &quot;operation&quot; : &quot;INSTALL&quot;
}</code></pre><p><strong>Step 4. Issue requests to our TrustedExtensions iControl LX extension</strong></p>
<div id='asg-get-trust-extension-command'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ curl -k -s -H &#39;Content-Type: application/json&#39; https://localhost:8443/mgmt/shared/TrustedExtensions?targetHost=localhost|json_pp
[
    {
        &quot;name&quot;: &quot;TrustedProxy&quot;,
        &quot;version&quot;: &quot;1.0.0&quot;,
        &quot;release&quot;: &quot;0001&quot;,
        &quot;arch&quot;: &quot;noarch&quot;,
        &quot;packageName&quot;: &quot;TrustedProxy-1.0.0-0001.noarch&quot;,
        &quot;tags&quot;: [
            &quot;PLUGIN&quot;
        ]
    },
    {
        &quot;name&quot;: &quot;TrustedDevices&quot;,
        &quot;version&quot;: &quot;1.0.0&quot;,
        &quot;release&quot;: &quot;0001&quot;,
        &quot;arch&quot;: &quot;noarch&quot;,
        &quot;packageName&quot;: &quot;TrustedDevices-1.0.0-0001.noarch&quot;,
        &quot;tags&quot;: [
            &quot;PLUGIN&quot;
        ]
    },
    {
        &quot;name&quot;: &quot;TrustedExtensions&quot;,
        &quot;version&quot;: &quot;1.0.0&quot;,
        &quot;release&quot;: &quot;0001&quot;,
        &quot;arch&quot;: &quot;noarch&quot;,
        &quot;packageName&quot;: &quot;TrustedExtensions-1.0.0-0001.noarch&quot;,
        &quot;tags&quot;: [
            &quot;PLUGIN&quot;
        ]
    }
]</code></pre><p>Time for some questions to cement your understanding of iControl LX extensions:</p>
<p><em>Have you figured out the problem with using our new extension?</em> </p>
<p>What happens when you use an iControl LX extension to manage iControl LX extensions on the API Service Gateway? </p>
<p>Remember, every time you install or remove an iControl LX extension, on the API Services Gateway or any TMOS device, the iControl LX framework gets restarted. <em>Ouch!</em></p>
<p>What happens to the requests we are making to the iControl LX framework when it gets restart? All existing requests made to the device are disconnected and our place in any orchestration workflow is lost.</p>
<p>If the API Services Gateway was the only part of an orchestration ecosystem, such a failure would be catastrophic. However, in real life, somewhere in our ecosystem we persist the state of our workflows so we can recover from issues like restarting services. We can keep the API Services Gateway nice and simple, let it restart when it needs to, by requiring it to be <strong><em>only a component</em></strong> of a larger micro services framework.</p>
<hr>
<h3 id="summary-of-what-you-ve-learned">Summary of What You&#39;ve Learned</h3>
<p>You&#39;ve had your basic introduction to the F5 components in an orchestration ecosystem.</p>
<ul>
<li>Reduction of complexity through the use of declarative APIs, like AS3</li>
<li>Separation of concerns for TMOS authentication and authorization through the use of the API Services Gateway device trusts</li>
<li>Using an iControl LX extension as a proxy to trusted devices</li>
<li>Designing a declarative API using a schema</li>
<li>Using an iControl LX extension as a token service for trusted iControl REST communications</li>
<li>Simplifying a complex task to make it as easy possible on the end user</li>
</ul>
<p>Now, let&#39;s move into the real world. Let&#39;s examine and use a simplified micro services framework which wraps in everything we&#39;ve learned so far and puts it to use within a standards based OpenAPI application.</p>
<hr>
<h2 id="demonstration-integration-exercises">Demonstration Integration Exercises</h2>
<p>In the following exercises we are going to illustrate the use of the API Services Gateway as part of an orchestration application. The orchestration application is made up of multiple micro services. We are going to launch all of these micro services as a single deployment using <code>docker-compose</code></p>
<p>In these exercises you will need:</p>
<ul>
<li>At least one target BIG-IP system whose management address is reachable from the API Services Gateway container</li>
<li>Administrative role credentials to the BIG-IP in order to create a device trust with the API Services Gateway</li>
<li>The ability to launch a deployment of containers using <code>docker-compose</code></li>
</ul>
<h3 id="exercise-11-launching-the-micro-services-deployment-with-docker-compose">Exercise #11 - Launching The Micro Services Deployment with <code>docker-compose</code></h3>
<p><strong>Step 1. Running <code>docker-compose</code></strong></p>
<p>Start your ssh client and login with the username, password, and host shown on the console.</p>
<div id='asg-ssh-login'>

<p><strong><code>ssh ubuntu@[Your F5 Container Demonstration Device IP]</code></strong></p>
<pre><code>ubuntu@ip-10-1-1-8</code></pre></div>

<p>Once you are logged in, use the <code>docker-compose</code> orchestrator to launch our micro services. We will start our docker containers by issueing the <code>up</code> command in our home directory.</p>
<div id='app-docker-compose-up'>

</div>

<pre><code>ubuntu@ip-10-1-1-8:~$ docker-compose up</code></pre><p>This command will start a flurry of activity in your terminal session as three services intialize and gradually communicate with each other to reach a ready state for external API access.</p>
<p><strong>Note:</strong> watch some of what&#39;s going on. Do you see anything familiar? You should see many iControl REST URIs that you recognize as our application installs our TrustedDevices, TrustedProxy, and TrustedExtensions iControl LX extensions to the Application Services Gateway. Our application will use these extensions to provision the BIG-IPs.</p>
<p>In the home directory there is a <code>docker-compose.yaml</code> file which details what container images to start and their relationship with each other. Our example deployment is comprised of 3 service, each in their own container. </p>
<ul>
<li><code>f5-api-services-gateway</code> stock container with no configuration</li>
<li><code>mongodb</code> stock container with only authentication sepcified</li>
<li><code>f5-appsvcs-demo</code> our OpenAPI application which handles our API endpoints and initializes our ecosystem to a ready state.</li>
</ul>
<p>Feel free to examine the <code>/home/ubuntu/docker-compose.yaml</code> file which describes our services. Our deployment uses <code>linked</code> containers, meaning they have access to each other by name, and are available to each other over a private network.</p>
<p>Only our <code>f5-appsvcs-demo</code> container will have inbound access via an exposed TCP port. Our micro services ecosystem is effectively firewalled. This is how we mitagate the need to secure the <code>f5-api-services-gateway</code>. It simply can not be access because the container has no exposed ports. By our <code>docker-compose.yaml</code> declaration, our <code>f5-appsvcs-demo</code> alone exposes a port and then only one, TCP port 3000.</p>
<p><img src="./assets/images/f5-appsvcs-demo-microservices-diagram.png" alt="An Example Micro Service Orchestration Application"></p>
<p><strong>Note:</strong> This is a very simple example. Our customers have Kubernetes orchestrated deployments which can be auto-scaled to load. It is not uncommon for a micro services architecture to be comprised of dozens of containerized services, each dynamically provised by a container orchestrator. We&#39;re just using <code>docker-compose</code> to aquaint you with the concepts and where the F5 API Services Gateway fits into a micro services deployment.</p>
<p><strong>Step 2. Validate the Demonstration app is running querying the OpenAPI Documentation user interface</strong></p>
<p>Our <code>f5-appsvcs-demo</code> application implements our OpenAPI schema in the <code>/api</code> namespace. The schema derived user interface can be reached at <code>/api-docs/</code>.</p>
<p>Open a web browser and navigate to:</p>
<div id='app-openapi-url'>

<p><code>http://[Your F5 Container Demonstration Device IP]:3000/api-docs</code></p>
</div>

<p>You should see the OpenAPI generated UI being served by our application container.</p>
<p><img src="./assets/images/f5-apps-openapi-app-initial.png" alt="OpenAPI Generated GUI"></p>
<p>Feel free to read the introduction text. This text is embedded in our schema document. In fact the schema document is linked in the description text. Open the schema document and examine it. Or you can just click on the link below to examine our application&#39;s schema.</p>
<p><a href="./swagger.json">Demonstration Application OpenAPI Schema</a></p>
<p><strong>Step 3. Adding a initial user which will automatically get the User Administrator role</strong></p>
<p>One of our primary goals was to eliminate the TMOS authentication and authorization concerns. That doesn&#39;t mean we do without authentication or authorization. It simply means our customer&#39;s choose what authentication and authorization schemes fits their services. Our example application uses a very common authenication plugin <a href="http://www.passportjs.org/">Passport JS</a>. Passport JS supports hundreds of password schemes from OAUTH2, Google, Facebook, Twitter, AWS, Azure, OpenStack Keystone, to RADIUS, LDAP, and Active Directory.</p>
<p>For ease of demonstration, our application uses a simple HTTP BASIC authentication strategy.</p>
<p>Our application is clever enough to only require a password after the first user has been created through the API by issuing a <code>POST</code> request to the <code>/api/users</code> API endpoint. When the first user is created, that user automatically is given the <em>User Administrator</em> role, which can then create other users and change their roles. </p>
<p>Scroll down in our OpenAPI interface to the <code>POST /users</code> GUI widget. Expand the widget and using the <code>Try it out</code> button, create our first user by using the example input supplied and clicking the blue <code>Execute</code> bar. This will create the <code>admin</code> user with the password <code>F5RocksAPIs!</code>.</p>
<p><img src="./assets/images/f5-apps-openapi-app-user-post.png" alt="POST to /users"></p>
<hr>
<p><strong>What Just Happened?</strong> </p>
<p>The example input from the schema definition was submitted to the API endpoint. The OpenAPI user interface uses your browser XHR (XMLHttpRequest) client to issue requests to defined API endpoints. </p>
<p>If you scroll down the page you will see the <em>Responses</em> section. That&#39;s a live response to your browser&#39;s API request.</p>
<p>The section also gives you curl syntax to duplicate the request from a command line script.</p>
<p><img src="./assets/images/f5-apps-openapi-app-user-post-response.png" alt="POST response to /users"></p>
<p>Neat! This OpenAPI stuff is pretty cool.</p>
<hr>
<p>Since we have created the first user, the application is built to require all further access to <code>/api/users</code>, <code>/api/{userId}</code>,<code>/api/deployments</code>, <code>/api/deployments/{deploymentId}</code>,<code>/api/devices</code>, <code>/api/devices/{deviceId}</code>, and <code>/api/extensions/{extensionId}</code> endpoints be protected with HTTP BASIC authentication.</p>
<p>The OpenAPI UI makes this easy by giving a way to include the HTTP BASIC authentication headers in all browser XHR requests. Look for the <code>Authorize</code> button above the API endpoint widgets. Click the <code>Authorize</code> button and fill in the credentials for your <code>admin</code> user with the <code>F5RocksAPIs!</code> password. </p>
<p><img src="./assets/images/f5-apps-openapi-app-input-credentials.png" alt="Add credentials"></p>
<hr>
<p><strong><em>How Do I Add Security to Micro Services?</em></strong></p>
<p>There are open and closed source micro services middleware and API security products available which restrict API endpoint access in many ways. This includes adding authentication and authorization services. </p>
<p>API security services can be added by:</p>
<p>1) inclusion in your application code as middleware</p>
<p>or </p>
<p>2) forcing request and response traffic through a security proxy using our container orchestrator</p>
<p>The <em>Passport JS</em> authentication service in our application utilizes <em>node express&#39;</em> middleware interfaces. We directly included the <em>Passport JS</em> request and response processing in our application code. The OpenAPI schema validation is also included as application middleware. Many applications <em>chain</em> together request and response middleware to integrate into ecosystems.</p>
<p><a href="https://istio.io/">istio</a> and <a href="https://aspenmesh.io/">F5 Apen Mesh</a> are examples of products where the container orchestrator is used to force access to micro services through a security proxy. This approach is also known as having <em>sidecar</em> containers. There is a vibrant market place emerging for such <em>sidecar</em> containers. The emergence is closely linked to containerized deployment orchestration, as it is the orchestrator which typically deploys the services in a way which forces the traffic through the <em>sidecar</em>.</p>
<p>For TMOS device orchestration, we are <em>not</em> concerned with providing framework middleware or containerized proxies which restrict access to provisioning BIG-IPs. Our job is to make the provisioning of services on our devices as simple as possible. <em>Separation of concerns</em> is a very important thing to implement in micro services. We play our role, others play theirs.</p>
<hr>
<p>Notice that the <em>roles</em> associated with our users are defined by the application. The <em>roles</em> have nothing to do with TMOS roles. </p>
<p>Our example application has a primitive tag based roles system. A user account aquires a role by having the user&#39;s <code>roles</code> attribute include the role&#39;s tag name. Our example application has only two roles:</p>
<hr>
<table>
<thead>
<tr>
<th align="left">Role Tag</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">User Administrator</td>
<td align="left">This role allows for the management of users in our application</td>
</tr>
<tr>
<td align="left">BIGIP Administrator</td>
<td align="left">This role allows for the management of Deployments of BIG-IPs</td>
</tr>
</tbody></table>
<hr>
<p><strong>Step 4. Adding the BIGIP Administrator role to our demonstration application user</strong></p>
<p>Let&#39;s update (in REST that&#39;s a <code>PUT</code> request) our <code>admin</code> user to have the <code>BIGIP Administrator</code> role.</p>
<p>See if you can&#39;t figure out how to make the <code>PUT</code> request to the <code>/users/{userId}</code> API endpoint. You&#39;ll notice our schema example already has what you need built in. You will need the <code>id</code> of the <code>user</code> created by your <code>POST</code> request. You can copy that from the response section of our <code>POST</code> request.</p>
<p><img src="./assets/images/f5-apps-openapi-app-user-put-request.png" alt="Adding the BIGIP Administrator role"></p>
<p><strong>Step 5. Using iControl LX Extensions in Our Application</strong></p>
<p>Before we start making iControl REST requests through the API Services Gateway, we still need to simplify many aspects of dealing with TMOS devices and extensions. We created a set of iControl LX extensions to do that, so why not use them as part of our micro servies orchestration. </p>
<p>When you first started the application there was a fury of iControl REST calls which took place between the application container and the API Services Gateway. Scroll down to the <code>GET</code> <code>/extensions</code> API endpoint. List the iControl LX extensions our application has already loaded. See if you don&#39;t recognize them.</p>
<p><img src="./assets/images/f5-apps-openapi-app-extensions-get.png" alt="List Gateway Extensions"></p>
<p>Notice our little toolkit of extensions were loaded from file URLs into the API Services Gateway. <strong>iControl LX extensions become the building blocks of larger orchestrations.</strong> If you don&#39;t understand that by now, we&#39;ve failed you!</p>
<p>Scroll back up to the <code>/deployments</code> API endpoints.</p>
<p><strong>Step 6. Managing BIG-IP Deployments</strong></p>
<p>Our application is going to tie all three of our iControl LX extensions, TrustedDevices, TrustedProxy, and TrustedExtensions, from our previous exercises together into one simplified API user experience. </p>
<p>We are going to define a <code>deployment</code> of BIG-IPs. Each deployment will have an <code>id</code> and <code>name</code> attribute to help us identify them. A <code>deployment</code> will also have a list of BIG-IP targets to establish trust. Our <code>deployment</code> will allow you to input a list of <code>url</code> attributes for iControl LX extensions which will be downloaded to our services, uploaded to the <code>deployment&#39;s</code> BIG-IP targets, and installed. </p>
<p>Once a <code>deployment</code> is created, anyone can use either the <code>/api/deployments/{deploymentId}/proxy/{iControlRestURIEndpoint}</code> or the <code>/api/devices/{deviceId}/proxy/{iControlRestURIEndpoint}</code> API endpoints to issue iControl REST calls to our trusted BIG-IP devices as the TMOS Administrator role on the BIG-IP. These calls can be done without authentication or authorization.</p>
<p>In our application, we&#39;ve decided that no authentication or roles are requires to issue iControl REST requests to trusted BIG-IPs. It is not what you would do in real life, but it&#39;s making the point that the concern for TMOS secured access is provided by integrating our application with the API Services Gateway. Application Middleware or sidecar proxies can be added to our ecosystem of sevices to properly restrict access to roles defined within the ecosystem, not TMOS.</p>
<p>The various models and objects defined in our OpenAPI schema for our application can be examined here:</p>
<p><a href="./swagger.json">Demonstration Application OpenAPI Schema</a></p>
<p>The basic format of a deployment request can be seen from the example presented in the OpenAPI user interface for the <code>POST</code> request on the <code>/api/deployments</code> endpoint.</p>
<pre><code>{
    &quot;name&quot;: &quot;dmzProxies&quot;,
    &quot;devices&quot;: [{
            &quot;targetHost&quot;: &quot;10.1.1.7&quot;,
            &quot;targetPort&quot;: 443,
            &quot;targetUsername&quot;: &quot;admin&quot;,
            &quot;targetPassphrase&quot;: &quot;admin&quot;
        },
        {
            &quot;targetHost&quot;: &quot;10.1.1.7&quot;,
            &quot;targetPort&quot;: 443,
            &quot;targetUsername&quot;: &quot;admin&quot;,
            &quot;targetPassphrase&quot;: &quot;admin&quot;
        }
    ],
    &quot;extensions&quot;: [{
        &quot;url&quot;: &quot;https://github.com/F5Networks/f5-appsvcs-extension/releases/download/v3.5.0/f5-appsvcs-3.5.0-3.noarch.rpm&quot;
    }]
}</code></pre><p>Chances are, without looking at the schema or knowing much about BIG-IPs, you can figure this out.</p>
<p>Fill in the IP address(es) and port(s) for the BIG-IP(s) you want to add to your deployment. List only the ones you wanted included. Creating a trusted device requires the <code>targetUsername</code> and <code>targetPassphrase</code> attributes. Once the trust is established with the API Servies Gateway, the TMOS credentials are not stored in the application nor on the API Services Gateway. We loose concern for them.</p>
<p>You can leave the AS3 <code>url</code> attributed in the example <code>extensions</code> list of your <code>/api/deployments</code> <code>POST</code>. Make sure and clean up the rest of the example, removing anything that would not be correct for your deployment. </p>
<p>If you follow the example deployment, trust will be established between the API Services Gateway and the specified devices. The AS3 iControl LX extension will be downloaded to our application, uploaded to the trusted devices, and installed on each device in the deployment. We made this process sychronous. AS3 is huge, weighing in at almost 50M bytes. It&#39;s a good stress test for syncrhonous uploading and install timing.</p>
<p>After editing the content of the <code>POST</code> request, submit your request to create your deployment.</p>
<p><img src="./assets/images/f5-apps-openapi-app-deployments-post.png" alt="Creating a Deployment"></p>
<p>Navigate to the <code>PUT</code> <code>/api/deployments/{deploymentId}</code> endpoint. You can use this endpoint to update your deployment. If you remove a trusted device, the deployment will no longer include that device. However, if that device was also a member of a different deployment, the trust will remain on the API Services Gateway. You can also choose to add or remove extensions by URL to a deployment through the <code>PUT</code> <code>/api/deployments/{deploymentId}</code> API endpoint.</p>
<p>While we are not adding security in our example, it is important to note that security boundaries are often enforced by URL namespaces. Having a means to anchor methods on a specific set of devices is a great way to design for furture API security.</p>
<p>Navigate to the <code>DELETE</code> <code>/api/deployments/{deploymentId}</code> API endpoint. A deployment can quickly be discarded. Again, if devices joined to a deployment are present in other deployments, they will remain trusted on the API Services Gateway. Only when a device is no longer in any deployments will the <code>DELETE</code> <code>/api/deployments/{deploymentId}</code> API endpoint remove the extensions from any trusted devices and remove the device trust from the API Services Gateway.</p>
<p><strong>Step 7. Exploring Trusted Devices</strong></p>
<p>Scroll down the page until you see the <code>GET</code> <code>/api/devices</code> API endpoint. This endpoint will help you catalog your devices, regardless of the deployment to which they are joined. </p>
<p><strong>Step 8. Exploring Available Extensions</strong></p>
<p>Scroll down the page until you see the <code>GET</code> <code>/api/extensions</code> API endpoint. This enpoint will help you inventory which extensions have previously been downloaded into our application. Once they are available in the application, that specific verison of our iControl LX extension does not need to be downloaded again.</p>
<p>We looked at this endpoint before to show you what got installed to the API Services Gateway when our application started. This time we emphasize the endpoint as a way to inventory your ecosystem from other services.</p>
<p>So far every API endpoint in our application has required authentication with a user with the <code>BIGIP Administrator</code> role. </p>
<h3 id="exercise-12-making-trusted-icontrol-rest-request-to-remote-big-ips">Exercise #12 - Making Trusted iControl REST Request to Remote BIG-IPs</h3>
<p><strong>Step 9. Make a Trusted iControl REST Request to All Devices in A Deployment</strong></p>
<p>Issuing iControl REST requests to trusted devices through our application requires no authentication nor role. You can prove this to yourself by navigating to the top of the OpenAPI widgets and removing your authentication credentials. </p>
<p>Let&#39;s perform some iControl REST requests which you might want to invoke on whole deployments of BIG-IPs at the same time. You can probably imagine many tasks which regularly need to be done on sets of BIG-IPs as part of regular operations. Let&#39;s select tasks that would likely require data from another part of your ecosystem. Most SDN controllers dynamically generate and manage VLANs. Let&#39;s manage a VLAN on multiple BIG-IPs at once through our deployment.</p>
<p>To cememnt our understanding, let&#39;s assume that a Cisco APIC SDN controller dynamically provisions a VLAN with segmentation ID <code>2018</code> which needs to be bound to every BIG-IP in our deployment on interface 1.1.</p>
<p>The iControl REST API endpoint to manage VLANs is <code>/mgmt/tm/net/vlan</code>. Let&#39;s start by listing our VLANs on all devices in our deployment using <code>GET</code> <code>/api/deployments/{deploymentId}</code> API endpoint.</p>
<p><img src="./assets/images/f5-apps-openapi-app-deployments-icontrol-list-vlans.png" alt="Listing VLANs"></p>
<p>Notice the deployment is returned a list of responses with an <code>id</code> attributes matching the trusted device <code>id</code>, <code>status</code> attribute representing the HTTP status code returned from our request, <code>responseHeaders</code> attribute which details the headers returned from the request, and a <code>body</code> attribute which is the request response.</p>
<p>We can then use the <code>POST</code> <code>/api/deployments/{deploymentId}</code> API endpoint to create the VLAN on each trusted device. </p>
<p>Again, the iControl REST API enpoint to manage VLANs is <code>/mgmt/tm/net/vlan</code>. Here is the request body we will use to create our VLAN:</p>
<pre><code>{
    &quot;name&quot;: &quot;apic2018&quot;,
    &quot;tag&quot;: &quot;2018&quot;,
    &quot;interfaces&quot;: [{
        &quot;name&quot;: &quot;1.1&quot;,
        &quot;tagged&quot;: true
    }]
}</code></pre><p><img src="./assets/images/f5-apps-openapi-app-deployments-icontrol-create-vlans.png" alt="creating a VLAN on multiple BIG-IPs"></p>
<p>To complete the lifecycle of our VLAN management, when we need remove the VLAN from our BIG-IPs. We can use the <code>DELETE</code> <code>/api/deployments/{deploymentId}</code>. You will need the <code>fullPath</code> attribute from our iControl REST returned VLAN replacing the path slashes with tildas (<code>~</code>). That is iControl REST&#39;s URL namespace syntax, don&#39;t blame us.</p>
<p><img src="./assets/images/f5-apps-openapi-app-deployments-icontrol-delete-vlans.png" alt="Removing a VLAN on multiple BIG-IPs"></p>
<p><strong>Note:</strong> Why wouldn&#39;t we just do this through <em>Ansible</em> modules? You can. Our application could easily be replaced by <em>Ansible</em>, but you still need to build the support in the ecosystem for removing BIG-IP concerns through the API Services Gateway. This is just an example of how this could be done using a container based micro services approach. We opted for a containerized approach because the API Services Gateway is a container.</p>
<p><strong>Step 10. Making a Trusted iControl REST Request to a Single Device</strong></p>
<p>For completeness we will issue an iControl REST request to a single device. Naviagate to the <code>GET</code> <code>/devices/{deviceId}/proxy{iControlRestURIEndpoint}</code> API endpoint and issue the <code>/mgmt/shared/identified-devices/config/device-info</code> as supplied in the example. Note, again, that this request can be issued with concern for TMOS role.</p>
<p><img src="./assets/images/f5-apps-openapi-app-devices-icontrol-get-device-info.png" alt="Making iControl REST Request to a Single Trusted Device"></p>
<p>Most iControl REST provisioning tasks are device specific. This means the majority of the iControl REST requests will be made though the <code>/devices/{deviceId}/proxy{iControlRestURIEndpoint}</code> API endpoints, not to a deployment of multiple BIG-IPs.</p>
<p>Because requests made to the <code>/devices/{deviceId}/proxy{iControlRestURIEndpoint}</code> API endpoints are issued to specific iControl REST API endpoints on specific device, the HTTP status code, response headers, and body are directly proxied to the client. What you see as a status code, response headers, and body returned to your client is exactly what was recieved device.</p>
<p>Sticking to this direct proxy pattern will make the migration of existing iControl REST applications easier as the responses through our application are the same as they would be with devices today. The request&#39;s simply need to be redirected to our application&#39;s <code>/devices/{deviceId}/proxy{iControlRestURIEndpoint}</code> endpoints.</p>
<p>As existing iControl REST applications are decomposed into containerized services, with proper separation of concerns, using a direct proxy pattern with the API Service Gateway makes it easier to add security middleware or sidecar proxies as well.</p>
<h3 id="exercise-13-making-trusted-declarations-without-concern-for-tmos-roles">Exercise #13 - Making Trusted Declarations without Concern for TMOS Roles</h3>
<p><strong>Step 11. Make a Declaration to A Devices in A Deployment</strong></p>
<p>What good would our examples be if we didn&#39;t come full circle and issue a declaration without concern for TMOS roles? Make sure you have previously included the AS3 url in the <code>url</code> list of the <code>extensions</code> attribute of your deployment. </p>
<p>Let&#39;s issue an AS3 declaration to a specific device using the <code>POST</code> <code>/devices/{deviceId}/proxy{iControlRestURIEndpoint}</code> API endpoint.</p>
<p>We will deploy the sample AS3 declaration from the <a href="https://clouddocs.f5.com/products/extensions/f5-appsvcs-extension/3/userguide/composing-a-declaration.html#sample-declaration">AS3 clouddocs example</a>.</p>
<p>The AS3 iControl LX extension iControl REST API endpoint to make a declarations is <code>/mgmt/shared/appsvcs/declare</code>.</p>
<p>Our sample <code>POST</code> body is:</p>
<pre><code>{
     &quot;class&quot;: &quot;AS3&quot;,
     &quot;action&quot;: &quot;deploy&quot;,
     &quot;persist&quot;: true,
     &quot;declaration&quot;: {
         &quot;class&quot;: &quot;ADC&quot;,
         &quot;schemaVersion&quot;: &quot;3.0.0&quot;,
         &quot;id&quot;: &quot;example-declaration-01&quot;,
         &quot;label&quot;: &quot;Sample 1&quot;,
         &quot;remark&quot;: &quot;Simple HTTP application with round robin pool&quot;,
         &quot;Sample_01&quot;: {
             &quot;class&quot;: &quot;Tenant&quot;,
             &quot;defaultRouteDomain&quot;: 0,
             &quot;Application_1&quot;: {
                 &quot;class&quot;: &quot;Application&quot;,
                 &quot;template&quot;: &quot;http&quot;,
             &quot;serviceMain&quot;: {
                 &quot;class&quot;: &quot;Service_HTTP&quot;,
                 &quot;virtualAddresses&quot;: [
                     &quot;10.0.1.10&quot;
                 ],
                 &quot;pool&quot;: &quot;web_pool&quot;
                 },
                 &quot;web_pool&quot;: {
                     &quot;class&quot;: &quot;Pool&quot;,
                     &quot;monitors&quot;: [
                         &quot;http&quot;
                     ],
                     &quot;members&quot;: [
                         {
                             &quot;servicePort&quot;: 80,
                             &quot;serverAddresses&quot;: [
                                 &quot;192.0.1.10&quot;,
                                 &quot;192.0.1.11&quot;
                             ]
                         }
                     ]
                 }
             }
         }
     }
 }</code></pre><p><img src="./assets/images/f5-apps-openapi-app-devices-icontrol-post-as3-deploy.png" alt="Making an AS3 Declaration through the API Services Gateway"></p>
<p>In declarative fashion, Let&#39;s remove our declaration using the the <code>POST</code> <code>/devices/{deviceId}/proxy{iControlRestURIEndpoint}</code> API endpoint.</p>
<p><img src="./assets/images/f5-apps-openapi-app-devices-icontrol-post-as3-remove.png" alt="Removing an AS3 Declaration through the API Services Gateway"></p>
<p>We&#39;ll stop here for now, but we&#39;ll enhance our library of iControl LX extensions to include many other compoents which will prove useful to our partner and community ecosystem orchestrations. There are future development efforts begining which will make use of the API Serviecs Gateway to improve the reuse and supportability of our orchestrations across ecosystems.</p>
<p>If you want you can go back to <code>DELETE</code> on the <code>/deployments/{deploymentId}</code> API endpoint and remove your deployment. If it was the only one you created, you should see your extensions uninstalled from your remote trusted devices, and then the device trusts removed from the API Services Gateway.</p>
<p><img src="./assets/images/f5-apps-openapi-app-deployments-delete.png" alt="Delete our Deployment"></p>
<p><strong>Step 12. Removing the Application</strong></p>
<p>The is just one more thing to do, stop your micro services.</p>
<p>Use the docker-compose orchestrator to remove our micro services. We will remove our docker containers by issueing the down command in our home directory.</p>
<div id='app-docker-compose-down'>

</div>


<pre><code>ubuntu@ip-10-1-1-8:~$ docker-compose down</code></pre><hr>
<h1 id="the-api-service-gateway-in-next-generation-partner-ecosystems">The API Service Gateway in Next Generation Partner Ecosystems</h1>
<p>How do we keep up with rapidly developing service deployments in our every changing orchestration environments? We&#39;re betting on the ability to launch our containerized services. Our containerized services allow our customers to build distributed controllers which include secured access to BIG-IP provisioning. Our orchestration efforts become decoupled from partner dependencies and releases through iControl LX extensions declarative APIs. The internal workings of BIG-IP trusted access, iControl REST workflows, or even our ability to pivot to non-TMOS application delivery systems, can be masked from the partner ecosystem by consistent and maintainable declarations.</p>
<p>Perhaps you are thinking this sounds like how other container orchestrators, like Kubernetes, handle deployments. Exactly! We are meeting the market where it is and, hopefully, where it is going. REST APIs were a great step in providing standardized protocol access without proprietary agents. The next phase was providing declared services which integrate directly into containerized application deployments. If you did the exercises above, then you&#39;ve already seen how this all works together. The API Service Gateway provides the basis to greatly simply access to F5 services and build out a fully integrated ecosystem.</p>
<h1 id="how-can-i-capitalize-on-our-new-f5-orchestration-containers-">How Can I Capitalize On Our New F5 Orchestration Containers?</h1>
<p>There are multiple ways:</p>
<ul>
<li><p>Start educating your customers on the use of AS3 declarations. This prepares them for cloud ready orchestration.</p>
</li>
<li><p>Wait for F5 to release API Service Gateway controller services for specific ecosystems like APIC and OpenStack</p>
</li>
<li><p>Present the API Service Gateway to your customers who need to develop deep integrations with BIG-IP provisioning now.</p>
</li>
</ul>
<p>The exercises above were your introduction to ready yourself for cloud native orchestration. Some customers are already expecting you to understand these concepts. Other customers&#39; migration to cloud services might still be simply a plan. Either way, you can be ready to help them now.</p>
<script>
buildAS3Exercises();
buildASGExercises();
</script></div>

<script src="assets/js/index.js"></script>
<script src="assets/js/bootstrap.min.js"></script>
</body>
</html>